# Echidna Coverage Report

**Generated:** 2025-11-04 16:49:24
**Coverage File:** `echidna-corpus/covered.1762271321.txt`
**Timestamp:** 1762271321

## ğŸ“Š Overall Summary

| Metric | Value |
|--------|-------|
| **Total Contracts** | 20 |
| **Contracts Below 70%** | 17 |
| **Overall Line Coverage** | 6.81% |
| **Total Lines** | 6059 |
| **Covered Lines** | 413 |

âš ï¸ **Status:** 17 contract(s) below 70% coverage threshold

## ğŸ” Coverage Analysis Against Scope

âœ… All contracts in scope have coverage data.

## ğŸ“‹ Contracts Coverage by Package

### ğŸ“¦ Package:  src

| Contract | Coverage | Status | Functions | Details |
|----------|----------|--------|-----------|---------|
| ğŸ”´ **Escrow** | 0% | âŒ Fail | 0 | [View](#escrow) |
| ğŸŸ¡ **Node** | 67.66% | âŒ Fail | 45 | [View](#node) |
| ğŸŸ¢ **NodeFactory** | 75% | âœ… Pass | 1 | [View](#nodefactory) |
| ğŸŸ¢ **NodeRegistry** | 93.48% | âœ… Pass | 13 | [View](#noderegistry) |
| ğŸŸ¡ **ERC4626Router** | 68.09% | âŒ Fail | 6 | [View](#erc4626router) |
| ğŸŸ  **ERC7540Router** | 41.18% | âŒ Fail | 10 | [View](#erc7540router) |
| ğŸ”´ **FluidRewardsRouter** | 20% | âŒ Fail | 1 | [View](#fluidrewardsrouter) |
| ğŸ”´ **IncentraRouter** | 25% | âŒ Fail | 1 | [View](#incentrarouter) |
| ğŸ”´ **MerklRouter** | 20% | âŒ Fail | 1 | [View](#merklrouter) |
| ğŸ”´ **OneInchV6RouterV1** | 19.35% | âŒ Fail | 3 | [View](#oneinchv6routerv1) |
| ğŸ”´ **QuoterV1** | 0% | âŒ Fail | 0 | [View](#quoterv1) |
| ğŸŸ¡ **BaseComponentRouter** | 62.16% | âŒ Fail | 7 | [View](#basecomponentrouter) |
| ğŸ”´ **BaseQuoter** | 0% | âŒ Fail | 0 | [View](#basequoter) |
| ğŸ”´ **ErrorsLib** | 0% | âŒ Fail | 0 | [View](#errorslib) |
| ğŸ”´ **EventsLib** | 0% | âŒ Fail | 0 | [View](#eventslib) |
| ğŸ”´ **MathLib** | 0% | âŒ Fail | 0 | [View](#mathlib) |
| ğŸ”´ **RegistryAccessControl** | 0% | âŒ Fail | 0 | [View](#registryaccesscontrol) |
| ğŸŸ  **DigiftAdapter** | 42.94% | âŒ Fail | 22 | [View](#digiftadapter) |
| ğŸŸ¢ **DigiftAdapterFactory** | 100% | âœ… Pass | 1 | [View](#digiftadapterfactory) |
| ğŸŸ  **DigiftEventVerifier** | 30% | âŒ Fail | 4 | [View](#digifteventverifier) |



## ğŸ” Detailed Contract Analysis

### Escrow

**Coverage:** 0%
`â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘`

## ğŸ“ˆ Coverage Statistics

| Metric | Value |
|--------|-------|
| Total Functions | 0 |
| Line Coverage | 0% |

<details>
<summary>ğŸ“Š Full Coverage Report</summary>

```
ğŸ“„ File: src/Escrow.sol
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ (index)                    â”‚ Values â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ totalFunctions             â”‚ 0      â”‚
â”‚ fullyCoveredFunctions      â”‚ 0      â”‚
â”‚ coveredLines               â”‚ 0      â”‚
â”‚ revertedLines              â”‚ 0      â”‚
â”‚ untouchedLines             â”‚ 0      â”‚
â”‚ functionCoveragePercentage â”‚ 0      â”‚
â”‚ lineCoveragePercentage     â”‚ 0      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”˜

âŒ Warning: Coverage 0% below threshold 70%
```

</details>

### Node

**Coverage:** 67.66%
`â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘`

## ğŸ“ˆ Coverage Statistics

| Metric | Value |
|--------|-------|
| Total Functions | 45 |
| Line Coverage | 67.66% |

## âš ï¸ Uncovered Functions

| Index | Function Name | Touched | Reverted | Untouched Lines |
|-------|---------------|---------|----------|----------------|
| 0 | `addPolicies` | false | false | 1 |
| 1 | `removePolicies` | false | false | 1 |
| 2 | `removeComponent` | false | false | 7 |
| 3 | `removeRouter` | false | false | 3 |
| 4 | `addRebalancer` | true | false | 1 |
| 5 | `removeRebalancer` | false | false | 3 |
| 6 | `setNodeOwnerFeeAddress` | false | false | 4 |
| 7 | `rescueTokens` | false | false | 4 |
| 8 | `_payManagementFees` | true | false | 1 |
| 9 | `subtractProtocolExecutionFee` | true | false | 4 |
| 10 | `fulfillRedeemFromReserve` | true | false | 1 |
| 11 | `finalizeRedemption` | false | false | 2 |
| 12 | `requestRedeem` | true | false | 3 |
| 13 | `deposit` | true | false | 2 |
| 14 | `mint` | true | false | 3 |
| 15 | `withdraw` | true | false | 12 |
| 16 | `redeem` | true | false | 12 |
| 17 | `transfer` | true | false | 1 |
| 18 | `_fulfillRedeemFromReserve` | true | false | 8 |
| 19 | `_finalizeRedemption` | false | false | 11 |
| 20 | `_validateOwner` | true | false | 2 |
| 21 | `_runPolicies` | true | false | 1 |

## ğŸ” Uncovered Code Lines

### Function: `addPolicies`

```solidity
âŒ Untouched lines:
```

```solidity
NodeLib.addPolicies(registry, policies, sigPolicy, proof, proofFlags, sigs, policies_);
```

### Function: `removePolicies`

```solidity
âŒ Untouched lines:
```

```solidity
NodeLib.removePolicies(policies, sigPolicy, sigs, policies_);
```

### Function: `removeComponent`

```solidity
âŒ Untouched lines:
```

```solidity
if (!_isComponent(component)) revert ErrorsLib.NotSet();
```

```solidity
address router = componentAllocations[component].router;
```

```solidity
revert ErrorsLib.NonZeroBalance();
```

```solidity
revert ErrorsLib.NotBlacklisted();
```

```solidity
NodeLib.remove(components, component);
```

```solidity
delete componentAllocations[component];
```

```solidity
emit EventsLib.ComponentRemoved(component);
```

### Function: `removeRouter`

```solidity
âŒ Untouched lines:
```

```solidity
if (!isRouter[oldRouter]) revert ErrorsLib.NotSet();
```

```solidity
isRouter[oldRouter] = false;
```

```solidity
emit EventsLib.RouterRemoved(oldRouter);
```

### Function: `addRebalancer`

```solidity
âŒ Untouched lines:
```

```solidity
revert ErrorsLib.NotWhitelisted();
```

### Function: `removeRebalancer`

```solidity
âŒ Untouched lines:
```

```solidity
if (!isRebalancer[oldRebalancer]) revert ErrorsLib.NotSet();
```

```solidity
isRebalancer[oldRebalancer] = false;
```

```solidity
emit EventsLib.RebalancerRemoved(oldRebalancer);
```

### Function: `setNodeOwnerFeeAddress`

```solidity
âŒ Untouched lines:
```

```solidity
_nonZeroAddress(newNodeOwnerFeeAddress);
```

```solidity
if (newNodeOwnerFeeAddress == nodeOwnerFeeAddress) revert ErrorsLib.AlreadySet();
```

```solidity
nodeOwnerFeeAddress = newNodeOwnerFeeAddress;
```

```solidity
emit EventsLib.NodeOwnerFeeAddressSet(newNodeOwnerFeeAddress);
```

### Function: `rescueTokens`

```solidity
âŒ Untouched lines:
```

```solidity
if (token == asset) revert ErrorsLib.InvalidToken();
```

```solidity
if (_isComponent(token)) revert ErrorsLib.InvalidToken();
```

```solidity
IERC20(token).safeTransfer(recipient, amount);
```

```solidity
emit EventsLib.RescueTokens(token, recipient, amount);
```

### Function: `_payManagementFees`

```solidity
âŒ Untouched lines:
```

```solidity
revert ErrorsLib.NotEnoughAssetsToPayFees(feeForPeriod, IERC20(asset).balanceOf(address(this)));
```

### Function: `subtractProtocolExecutionFee`

```solidity
âŒ Untouched lines:
```

```solidity
cacheTotalAssets -= executionFee;
```

```solidity
IERC20(asset).safeTransfer(INodeRegistry(registry).protocolFeeAddress(), executionFee);
```

```solidity
_runPolicies();
```

```solidity
emit EventsLib.ExecutionFeeTaken(executionFee);
```

### Function: `fulfillRedeemFromReserve`

```solidity
âŒ Untouched lines:
```

```solidity
_runPolicies();
```

### Function: `finalizeRedemption`

```solidity
âŒ Untouched lines:
```

```solidity
_finalizeRedemption(controller, assetsToReturn, sharesPending, sharesAdjusted);
```

```solidity
_runPolicies();
```

### Function: `requestRedeem`

```solidity
âŒ Untouched lines:
```

```solidity
uint256 adjustedAssets = quoter.calculateRedeemPenalty(
```

```solidity
shares, getCashAfterRedemptions(), totalAssets(), maxSwingFactor, targetReserveRatio
```

```solidity
adjustedShares = Math.min(convertToShares(adjustedAssets), shares);
```

### Function: `deposit`

```solidity
âŒ Untouched lines:
```

```solidity
revert ErrorsLib.ExceedsMaxDeposit();
```

```solidity
return shares;
```

### Function: `mint`

```solidity
âŒ Untouched lines:
```

```solidity
revert ErrorsLib.ExceedsMaxMint();
```

```solidity
_runPolicies();
```

```solidity
return assets;
```

### Function: `withdraw`

```solidity
âŒ Untouched lines:
```

```solidity
_validateController(controller);
```

```solidity
Request storage request = requests[controller];
```

```solidity
uint256 maxAssets = maxWithdraw(controller);
```

```solidity
uint256 maxShares = maxRedeem(controller);
```

```solidity
if (assets > maxAssets) revert ErrorsLib.ExceedsMaxWithdraw();
```

```solidity
shares = Math.mulDiv(assets, maxShares, maxAssets, Math.Rounding.Ceil);
```

```solidity
request.claimableRedeemRequest -= shares;
```

```solidity
request.claimableAssets -= assets;
```

```solidity
IERC20(asset).safeTransferFrom(escrow, receiver, assets);
```

```solidity
_runPolicies();
```

```solidity
emit IERC7575.Withdraw(msg.sender, receiver, controller, assets, shares);
```

```solidity
return shares;
```

### Function: `redeem`

```solidity
âŒ Untouched lines:
```

```solidity
_validateController(controller);
```

```solidity
Request storage request = requests[controller];
```

```solidity
uint256 maxAssets = maxWithdraw(controller);
```

```solidity
uint256 maxShares = maxRedeem(controller);
```

```solidity
if (shares > maxShares) revert ErrorsLib.ExceedsMaxRedeem();
```

```solidity
assets = Math.mulDiv(shares, maxAssets, maxShares);
```

```solidity
request.claimableRedeemRequest -= shares;
```

```solidity
request.claimableAssets -= assets;
```

```solidity
IERC20(asset).safeTransferFrom(escrow, receiver, assets);
```

```solidity
_runPolicies();
```

```solidity
emit IERC7575.Withdraw(msg.sender, receiver, controller, assets, shares);
```

```solidity
return assets;
```

### Function: `transfer`

```solidity
âŒ Untouched lines:
```

```solidity
_runPolicies();
```

### Function: `_fulfillRedeemFromReserve`

```solidity
âŒ Untouched lines:
```

```solidity
uint256 balance = Math.max(IERC20(asset).balanceOf(address(this)), 1);
```

```solidity
uint256 assetsToReturn = convertToAssets(request.sharesAdjusted);
```

```solidity
uint256 sharesPending = request.pendingRedeemRequest;
```

```solidity
uint256 sharesAdjusted = request.sharesAdjusted;
```

```solidity
sharesPending = (sharesPending * balance - 1) / assetsToReturn + 1;
```

```solidity
sharesAdjusted = (sharesAdjusted * balance - 1) / assetsToReturn + 1;
```

```solidity
assetsToReturn = balance;
```

```solidity
_finalizeRedemption(controller, assetsToReturn, sharesPending, sharesAdjusted);
```

### Function: `_finalizeRedemption`

```solidity
âŒ Untouched lines:
```

```solidity
Request storage request = requests[controller];
```

```solidity
_burn(escrow, sharesPending);
```

```solidity
request.pendingRedeemRequest -= sharesPending;
```

```solidity
request.claimableRedeemRequest += sharesPending;
```

```solidity
request.claimableAssets += assetsToReturn;
```

```solidity
request.sharesAdjusted -= sharesAdjusted;
```

```solidity
sharesExiting -= sharesAdjusted;
```

```solidity
cacheTotalAssets -= assetsToReturn;
```

```solidity
revert ErrorsLib.ExceedsAvailableReserve();
```

```solidity
IERC20(asset).safeTransfer(escrow, assetsToReturn);
```

```solidity
emit EventsLib.RedeemClaimable(controller, REQUEST_ID, assetsToReturn, sharesPending);
```

### Function: `_validateOwner`

```solidity
âŒ Untouched lines:
```

```solidity
revert ErrorsLib.InvalidOwner();
```

```solidity
_spendAllowance(owner, msg.sender, shares);
```

### Function: `_runPolicies`

```solidity
âŒ Untouched lines:
```

```solidity
IPolicy(policies_[i]).onCheck(msg.sender, msg.data);
```

```solidity
âŒ Warning: Coverage 67.66% below threshold 70%
```


<details>
<summary>ğŸ“Š Full Coverage Report</summary>

```
ğŸ“„ File: src/Node.sol
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ (index)                    â”‚ Values â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ totalFunctions             â”‚ 45     â”‚
â”‚ fullyCoveredFunctions      â”‚ 23     â”‚
â”‚ coveredLines               â”‚ 182    â”‚
â”‚ revertedLines              â”‚ 0      â”‚
â”‚ untouchedLines             â”‚ 87     â”‚
â”‚ functionCoveragePercentage â”‚ 51.11  â”‚
â”‚ lineCoveragePercentage     â”‚ 67.66  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”˜

âš ï¸ Not fully covered functions:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ (index) â”‚ functionName                   â”‚ touched â”‚ reverted â”‚ untouchedLines â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 0       â”‚ 'addPolicies'                  â”‚ false   â”‚ false    â”‚ 1              â”‚
â”‚ 1       â”‚ 'removePolicies'               â”‚ false   â”‚ false    â”‚ 1              â”‚
â”‚ 2       â”‚ 'removeComponent'              â”‚ false   â”‚ false    â”‚ 7              â”‚
â”‚ 3       â”‚ 'removeRouter'                 â”‚ false   â”‚ false    â”‚ 3              â”‚
â”‚ 4       â”‚ 'addRebalancer'                â”‚ true    â”‚ false    â”‚ 1              â”‚
â”‚ 5       â”‚ 'removeRebalancer'             â”‚ false   â”‚ false    â”‚ 3              â”‚
â”‚ 6       â”‚ 'setNodeOwnerFeeAddress'       â”‚ false   â”‚ false    â”‚ 4              â”‚
â”‚ 7       â”‚ 'rescueTokens'                 â”‚ false   â”‚ false    â”‚ 4              â”‚
â”‚ 8       â”‚ '_payManagementFees'           â”‚ true    â”‚ false    â”‚ 1              â”‚
â”‚ 9       â”‚ 'subtractProtocolExecutionFee' â”‚ true    â”‚ false    â”‚ 4              â”‚
â”‚ 10      â”‚ 'fulfillRedeemFromReserve'     â”‚ true    â”‚ false    â”‚ 1              â”‚
â”‚ 11      â”‚ 'finalizeRedemption'           â”‚ false   â”‚ false    â”‚ 2              â”‚
â”‚ 12      â”‚ 'requestRedeem'                â”‚ true    â”‚ false    â”‚ 3              â”‚
â”‚ 13      â”‚ 'deposit'                      â”‚ true    â”‚ false    â”‚ 2              â”‚
â”‚ 14      â”‚ 'mint'                         â”‚ true    â”‚ false    â”‚ 3              â”‚
â”‚ 15      â”‚ 'withdraw'                     â”‚ true    â”‚ false    â”‚ 12             â”‚
â”‚ 16      â”‚ 'redeem'                       â”‚ true    â”‚ false    â”‚ 12             â”‚
â”‚ 17      â”‚ 'transfer'                     â”‚ true    â”‚ false    â”‚ 1              â”‚
â”‚ 18      â”‚ '_fulfillRedeemFromReserve'    â”‚ true    â”‚ false    â”‚ 8              â”‚
â”‚ 19      â”‚ '_finalizeRedemption'          â”‚ false   â”‚ false    â”‚ 11             â”‚
â”‚ 20      â”‚ '_validateOwner'               â”‚ true    â”‚ false    â”‚ 2              â”‚
â”‚ 21      â”‚ '_runPolicies'                 â”‚ true    â”‚ false    â”‚ 1              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Function: addPolicies
âŒ Untouched lines:
NodeLib.addPolicies(registry, policies, sigPolicy, proof, proofFlags, sigs, policies_);

Function: removePolicies
âŒ Untouched lines:
NodeLib.removePolicies(policies, sigPolicy, sigs, policies_);

Function: removeComponent
âŒ Untouched lines:
if (!_isComponent(component)) revert ErrorsLib.NotSet();
address router = componentAllocations[component].router;
revert ErrorsLib.NonZeroBalance();
revert ErrorsLib.NotBlacklisted();
NodeLib.remove(components, component);
delete componentAllocations[component];
emit EventsLib.ComponentRemoved(component);

Function: removeRouter
âŒ Untouched lines:
if (!isRouter[oldRouter]) revert ErrorsLib.NotSet();
isRouter[oldRouter] = false;
emit EventsLib.RouterRemoved(oldRouter);

Function: addRebalancer
âŒ Untouched lines:
revert ErrorsLib.NotWhitelisted();

Function: removeRebalancer
âŒ Untouched lines:
if (!isRebalancer[oldRebalancer]) revert ErrorsLib.NotSet();
isRebalancer[oldRebalancer] = false;
emit EventsLib.RebalancerRemoved(oldRebalancer);

Function: setNodeOwnerFeeAddress
âŒ Untouched lines:
_nonZeroAddress(newNodeOwnerFeeAddress);
if (newNodeOwnerFeeAddress == nodeOwnerFeeAddress) revert ErrorsLib.AlreadySet();
nodeOwnerFeeAddress = newNodeOwnerFeeAddress;
emit EventsLib.NodeOwnerFeeAddressSet(newNodeOwnerFeeAddress);

Function: rescueTokens
âŒ Untouched lines:
if (token == asset) revert ErrorsLib.InvalidToken();
if (_isComponent(token)) revert ErrorsLib.InvalidToken();
IERC20(token).safeTransfer(recipient, amount);
emit EventsLib.RescueTokens(token, recipient, amount);

Function: _payManagementFees
âŒ Untouched lines:
revert ErrorsLib.NotEnoughAssetsToPayFees(feeForPeriod, IERC20(asset).balanceOf(address(this)));

Function: subtractProtocolExecutionFee
âŒ Untouched lines:
cacheTotalAssets -= executionFee;
IERC20(asset).safeTransfer(INodeRegistry(registry).protocolFeeAddress(), executionFee);
_runPolicies();
emit EventsLib.ExecutionFeeTaken(executionFee);

Function: fulfillRedeemFromReserve
âŒ Untouched lines:
_runPolicies();

Function: finalizeRedemption
âŒ Untouched lines:
_finalizeRedemption(controller, assetsToReturn, sharesPending, sharesAdjusted);
_runPolicies();

Function: requestRedeem
âŒ Untouched lines:
uint256 adjustedAssets = quoter.calculateRedeemPenalty(
shares, getCashAfterRedemptions(), totalAssets(), maxSwingFactor, targetReserveRatio
adjustedShares = Math.min(convertToShares(adjustedAssets), shares);

Function: deposit
âŒ Untouched lines:
revert ErrorsLib.ExceedsMaxDeposit();
return shares;

Function: mint
âŒ Untouched lines:
revert ErrorsLib.ExceedsMaxMint();
_runPolicies();
return assets;

Function: withdraw
âŒ Untouched lines:
_validateController(controller);
Request storage request = requests[controller];
uint256 maxAssets = maxWithdraw(controller);
uint256 maxShares = maxRedeem(controller);
if (assets > maxAssets) revert ErrorsLib.ExceedsMaxWithdraw();
shares = Math.mulDiv(assets, maxShares, maxAssets, Math.Rounding.Ceil);
request.claimableRedeemRequest -= shares;
request.claimableAssets -= assets;
IERC20(asset).safeTransferFrom(escrow, receiver, assets);
_runPolicies();
emit IERC7575.Withdraw(msg.sender, receiver, controller, assets, shares);
return shares;

Function: redeem
âŒ Untouched lines:
_validateController(controller);
Request storage request = requests[controller];
uint256 maxAssets = maxWithdraw(controller);
uint256 maxShares = maxRedeem(controller);
if (shares > maxShares) revert ErrorsLib.ExceedsMaxRedeem();
assets = Math.mulDiv(shares, maxAssets, maxShares);
request.claimableRedeemRequest -= shares;
request.claimableAssets -= assets;
IERC20(asset).safeTransferFrom(escrow, receiver, assets);
_runPolicies();
emit IERC7575.Withdraw(msg.sender, receiver, controller, assets, shares);
return assets;

Function: transfer
âŒ Untouched lines:
_runPolicies();

Function: _fulfillRedeemFromReserve
âŒ Untouched lines:
uint256 balance = Math.max(IERC20(asset).balanceOf(address(this)), 1);
uint256 assetsToReturn = convertToAssets(request.sharesAdjusted);
uint256 sharesPending = request.pendingRedeemRequest;
uint256 sharesAdjusted = request.sharesAdjusted;
sharesPending = (sharesPending * balance - 1) / assetsToReturn + 1;
sharesAdjusted = (sharesAdjusted * balance - 1) / assetsToReturn + 1;
assetsToReturn = balance;
_finalizeRedemption(controller, assetsToReturn, sharesPending, sharesAdjusted);

Function: _finalizeRedemption
âŒ Untouched lines:
Request storage request = requests[controller];
_burn(escrow, sharesPending);
request.pendingRedeemRequest -= sharesPending;
request.claimableRedeemRequest += sharesPending;
request.claimableAssets += assetsToReturn;
request.sharesAdjusted -= sharesAdjusted;
sharesExiting -= sharesAdjusted;
cacheTotalAssets -= assetsToReturn;
revert ErrorsLib.ExceedsAvailableReserve();
IERC20(asset).safeTransfer(escrow, assetsToReturn);
emit EventsLib.RedeemClaimable(controller, REQUEST_ID, assetsToReturn, sharesPending);

Function: _validateOwner
âŒ Untouched lines:
revert ErrorsLib.InvalidOwner();
_spendAllowance(owner, msg.sender, shares);

Function: _runPolicies
âŒ Untouched lines:
IPolicy(policies_[i]).onCheck(msg.sender, msg.data);

âŒ Warning: Coverage 67.66% below threshold 70%
```

</details>

### NodeFactory

**Coverage:** 75%
`â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘`

## ğŸ“ˆ Coverage Statistics

| Metric | Value |
|--------|-------|
| Total Functions | 1 |
| Line Coverage | 75% |

## âš ï¸ Uncovered Functions

| Index | Function Name | Touched | Reverted | Untouched Lines |
|-------|---------------|---------|----------|----------------|
| 0 | `invest` | true | false | 4 |
| 1 | `liquidate` | false | false | 4 |
| 2 | `fulfillRedeemRequest` | true | false | 5 |
| 3 | `_redeem` | false | false | 2 |

## ğŸ” Uncovered Code Lines

```solidity
ğŸ“„ File: routers/ERC4626Router.sol
```

```solidity
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”
```

```solidity
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¤
```

```solidity
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

```solidity
âš ï¸ Not fully covered functions:
```

```solidity
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
```

```solidity
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
```

```solidity
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Function: `invest`

```solidity
âŒ Untouched lines:
```

```solidity
revert ExceedsMaxComponentDeposit(component, depositAmount, IERC4626(component).maxDeposit(address(node)));
```

```solidity
revert InsufficientSharesReturned(component, 0, expectedShares);
```

```solidity
revert InsufficientSharesReturned(component, sharesReturned, expectedShares);
```

```solidity
revert InsufficientSharesReturned(component, sharesReturned, minSharesOut);
```

### Function: `liquidate`

```solidity
âŒ Untouched lines:
```

```solidity
assetsReturned = _liquidate(node, component, shares);
```

```solidity
revert InsufficientAssetsReturned(component, assetsReturned, minAssetsOut);
```

```solidity
emit LiquidatedFromComponent(node, component, assetsReturned);
```

```solidity
return assetsReturned;
```

### Function: `fulfillRedeemRequest`

```solidity
âŒ Untouched lines:
```

```solidity
(sharesPending, sharesAdjusted) =
```

```solidity
_calculatePartialFulfill(sharesPending, assetsReturned, assetsRequested, sharesAdjusted);
```

```solidity
INode(node).finalizeRedemption(controller, assetsReturned, sharesPending, sharesAdjusted);
```

```solidity
emit FulfilledRedeemRequest(node, component, assetsReturned);
```

```solidity
return assetsReturned;
```

### Function: `_redeem`

```solidity
âŒ Untouched lines:
```

```solidity
bytes memory result = INode(node).execute(component, abi.encodeCall(IERC4626.redeem, (shares, node, node)));
```

```solidity
return abi.decode(result, (uint256));
```

```solidity
âŒ Warning: Coverage 68.09% below threshold 70%
```


<details>
<summary>ğŸ“Š Full Coverage Report</summary>

```
ğŸ“„ File: routers/ERC4626Router.sol
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ (index)                    â”‚ Values â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ totalFunctions             â”‚ 6      â”‚
â”‚ fullyCoveredFunctions      â”‚ 2      â”‚
â”‚ coveredLines               â”‚ 32     â”‚
â”‚ revertedLines              â”‚ 0      â”‚
â”‚ untouchedLines             â”‚ 15     â”‚
â”‚ functionCoveragePercentage â”‚ 33.33  â”‚
â”‚ lineCoveragePercentage     â”‚ 68.09  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”˜

âš ï¸ Not fully covered functions:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ (index) â”‚ functionName           â”‚ touched â”‚ reverted â”‚ untouchedLines â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 0       â”‚ 'invest'               â”‚ true    â”‚ false    â”‚ 4              â”‚
â”‚ 1       â”‚ 'liquidate'            â”‚ false   â”‚ false    â”‚ 4              â”‚
â”‚ 2       â”‚ 'fulfillRedeemRequest' â”‚ true    â”‚ false    â”‚ 5              â”‚
â”‚ 3       â”‚ '_redeem'              â”‚ false   â”‚ false    â”‚ 2              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Function: invest
âŒ Untouched lines:
revert ExceedsMaxComponentDeposit(component, depositAmount, IERC4626(component).maxDeposit(address(node)));
revert InsufficientSharesReturned(component, 0, expectedShares);
revert InsufficientSharesReturned(component, sharesReturned, expectedShares);
revert InsufficientSharesReturned(component, sharesReturned, minSharesOut);

Function: liquidate
âŒ Untouched lines:
assetsReturned = _liquidate(node, component, shares);
revert InsufficientAssetsReturned(component, assetsReturned, minAssetsOut);
emit LiquidatedFromComponent(node, component, assetsReturned);
return assetsReturned;

Function: fulfillRedeemRequest
âŒ Untouched lines:
(sharesPending, sharesAdjusted) =
_calculatePartialFulfill(sharesPending, assetsReturned, assetsRequested, sharesAdjusted);
INode(node).finalizeRedemption(controller, assetsReturned, sharesPending, sharesAdjusted);
emit FulfilledRedeemRequest(node, component, assetsReturned);
return assetsReturned;

Function: _redeem
âŒ Untouched lines:
bytes memory result = INode(node).execute(component, abi.encodeCall(IERC4626.redeem, (shares, node, node)));
return abi.decode(result, (uint256));

âŒ Warning: Coverage 68.09% below threshold 70%
```

</details>

### NodeRegistry

**Coverage:** 93.48%
`â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘`

## ğŸ“ˆ Coverage Statistics

| Metric | Value |
|--------|-------|
| Total Functions | 13 |
| Line Coverage | 93.48% |

## âš ï¸ Uncovered Functions

| Index | Function Name | Touched | Reverted | Untouched Lines |
|-------|---------------|---------|----------|----------------|
| 0 | `fulfillRedeemRequest` | false | false | 11 |
| 1 | `investInAsyncComponent` | true | false | 1 |
| 2 | `mintClaimableShares` | true | false | 5 |
| 3 | `requestAsyncWithdrawal` | false | false | 5 |
| 4 | `executeAsyncWithdrawal` | false | false | 1 |
| 5 | `_requestRedeem` | false | false | 5 |
| 6 | `_withdraw` | false | false | 2 |
| 7 | `_executeAsyncWithdrawal` | false | false | 10 |

## ğŸ” Uncovered Code Lines

### Function: `fulfillRedeemRequest`

```solidity
âŒ Untouched lines:
```

```solidity
(uint256 sharesPending,,, uint256 sharesAdjusted) = INode(node).requests(controller);
```

```solidity
uint256 assetsRequested = INode(node).convertToAssets(sharesAdjusted);
```

```solidity
INode(node).enforceLiquidationOrder(component, assetsRequested);
```

```solidity
uint256 maxClaimableRedeemRequest = IERC7540Redeem(component).claimableRedeemRequest(0, node);
```

```solidity
uint256 maxClaimableAssets = IERC7575(component).convertToAssets(maxClaimableRedeemRequest);
```

```solidity
assetsReturned = _executeAsyncWithdrawal(node, component, Math.min(assetsRequested, maxClaimableAssets));
```

```solidity
(sharesPending, sharesAdjusted) =
```

```solidity
_calculatePartialFulfill(sharesPending, assetsReturned, assetsRequested, sharesAdjusted);
```

```solidity
INode(node).finalizeRedemption(controller, assetsReturned, sharesPending, sharesAdjusted);
```

```solidity
emit FulfilledRedeemRequest(node, component, assetsReturned);
```

```solidity
return assetsReturned;
```

### Function: `investInAsyncComponent`

```solidity
âŒ Untouched lines:
```

```solidity
revert IncorrectRequestId(requestId);
```

### Function: `mintClaimableShares`

```solidity
âŒ Untouched lines:
```

```solidity
uint256 balanceAfter = IERC20(share).balanceOf(address(node));
```

```solidity
sharesReceived = balanceAfter - balanceBefore;
```

```solidity
revert InsufficientSharesReturned(component, sharesReceived, claimableShares);
```

```solidity
emit MintedClaimableShares(node, component, sharesReceived);
```

```solidity
return sharesReceived;
```

### Function: `requestAsyncWithdrawal`

```solidity
âŒ Untouched lines:
```

```solidity
address shareToken = IERC7575(component).share();
```

```solidity
revert ExceedsAvailableShares(node, component, shares);
```

```solidity
uint256 requestId = _requestRedeem(node, component, shares);
```

```solidity
revert IncorrectRequestId(requestId);
```

```solidity
emit RequestedAsyncWithdrawal(node, component, shares);
```

### Function: `executeAsyncWithdrawal`

```solidity
âŒ Untouched lines:
```

```solidity
assetsReceived = _executeAsyncWithdrawal(node, component, assets);
```

### Function: `_requestRedeem`

```solidity
âŒ Untouched lines:
```

```solidity
address shareToken = IERC7575(component).share();
```

```solidity
_safeApprove(node, shareToken, component, shares);
```

```solidity
bytes memory result =
```

```solidity
INode(node).execute(component, abi.encodeCall(IERC7540Redeem.requestRedeem, (shares, node, node)));
```

```solidity
return abi.decode(result, (uint256));
```

### Function: `_withdraw`

```solidity
âŒ Untouched lines:
```

```solidity
bytes memory result = INode(node).execute(component, abi.encodeCall(IERC7575.withdraw, (assets, node, node)));
```

```solidity
return abi.decode(result, (uint256));
```

### Function: `_executeAsyncWithdrawal`

```solidity
âŒ Untouched lines:
```

```solidity
revert ExceedsAvailableAssets(node, component, assets);
```

```solidity
address asset = IERC7575(node).asset();
```

```solidity
uint256 balanceBefore = IERC20(asset).balanceOf(address(node));
```

```solidity
_withdraw(node, component, assets);
```

```solidity
uint256 balanceAfter = IERC20(asset).balanceOf(address(node));
```

```solidity
revert InsufficientAssetsReturned(component, 0, assets);
```

```solidity
assetsReceived = balanceAfter - balanceBefore;
```

```solidity
revert InsufficientAssetsReturned(component, assetsReceived, assets);
```

```solidity
emit AsyncWithdrawalExecuted(node, component, assetsReceived);
```

```solidity
return assetsReceived;
```

```solidity
âŒ Warning: Coverage 41.18% below threshold 70%
```


<details>
<summary>ğŸ“Š Full Coverage Report</summary>

```
ğŸ“„ File: routers/ERC7540Router.sol
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ (index)                    â”‚ Values â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ totalFunctions             â”‚ 10     â”‚
â”‚ fullyCoveredFunctions      â”‚ 2      â”‚
â”‚ coveredLines               â”‚ 28     â”‚
â”‚ revertedLines              â”‚ 0      â”‚
â”‚ untouchedLines             â”‚ 40     â”‚
â”‚ functionCoveragePercentage â”‚ 20     â”‚
â”‚ lineCoveragePercentage     â”‚ 41.18  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”˜

âš ï¸ Not fully covered functions:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ (index) â”‚ functionName              â”‚ touched â”‚ reverted â”‚ untouchedLines â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 0       â”‚ 'fulfillRedeemRequest'    â”‚ false   â”‚ false    â”‚ 11             â”‚
â”‚ 1       â”‚ 'investInAsyncComponent'  â”‚ true    â”‚ false    â”‚ 1              â”‚
â”‚ 2       â”‚ 'mintClaimableShares'     â”‚ true    â”‚ false    â”‚ 5              â”‚
â”‚ 3       â”‚ 'requestAsyncWithdrawal'  â”‚ false   â”‚ false    â”‚ 5              â”‚
â”‚ 4       â”‚ 'executeAsyncWithdrawal'  â”‚ false   â”‚ false    â”‚ 1              â”‚
â”‚ 5       â”‚ '_requestRedeem'          â”‚ false   â”‚ false    â”‚ 5              â”‚
â”‚ 6       â”‚ '_withdraw'               â”‚ false   â”‚ false    â”‚ 2              â”‚
â”‚ 7       â”‚ '_executeAsyncWithdrawal' â”‚ false   â”‚ false    â”‚ 10             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Function: fulfillRedeemRequest
âŒ Untouched lines:
(uint256 sharesPending,,, uint256 sharesAdjusted) = INode(node).requests(controller);
uint256 assetsRequested = INode(node).convertToAssets(sharesAdjusted);
INode(node).enforceLiquidationOrder(component, assetsRequested);
uint256 maxClaimableRedeemRequest = IERC7540Redeem(component).claimableRedeemRequest(0, node);
uint256 maxClaimableAssets = IERC7575(component).convertToAssets(maxClaimableRedeemRequest);
assetsReturned = _executeAsyncWithdrawal(node, component, Math.min(assetsRequested, maxClaimableAssets));
(sharesPending, sharesAdjusted) =
_calculatePartialFulfill(sharesPending, assetsReturned, assetsRequested, sharesAdjusted);
INode(node).finalizeRedemption(controller, assetsReturned, sharesPending, sharesAdjusted);
emit FulfilledRedeemRequest(node, component, assetsReturned);
return assetsReturned;

Function: investInAsyncComponent
âŒ Untouched lines:
revert IncorrectRequestId(requestId);

Function: mintClaimableShares
âŒ Untouched lines:
uint256 balanceAfter = IERC20(share).balanceOf(address(node));
sharesReceived = balanceAfter - balanceBefore;
revert InsufficientSharesReturned(component, sharesReceived, claimableShares);
emit MintedClaimableShares(node, component, sharesReceived);
return sharesReceived;

Function: requestAsyncWithdrawal
âŒ Untouched lines:
address shareToken = IERC7575(component).share();
revert ExceedsAvailableShares(node, component, shares);
uint256 requestId = _requestRedeem(node, component, shares);
revert IncorrectRequestId(requestId);
emit RequestedAsyncWithdrawal(node, component, shares);

Function: executeAsyncWithdrawal
âŒ Untouched lines:
assetsReceived = _executeAsyncWithdrawal(node, component, assets);

Function: _requestRedeem
âŒ Untouched lines:
address shareToken = IERC7575(component).share();
_safeApprove(node, shareToken, component, shares);
bytes memory result =
INode(node).execute(component, abi.encodeCall(IERC7540Redeem.requestRedeem, (shares, node, node)));
return abi.decode(result, (uint256));

Function: _withdraw
âŒ Untouched lines:
bytes memory result = INode(node).execute(component, abi.encodeCall(IERC7575.withdraw, (assets, node, node)));
return abi.decode(result, (uint256));

Function: _executeAsyncWithdrawal
âŒ Untouched lines:
revert ExceedsAvailableAssets(node, component, assets);
address asset = IERC7575(node).asset();
uint256 balanceBefore = IERC20(asset).balanceOf(address(node));
_withdraw(node, component, assets);
uint256 balanceAfter = IERC20(asset).balanceOf(address(node));
revert InsufficientAssetsReturned(component, 0, assets);
assetsReceived = balanceAfter - balanceBefore;
revert InsufficientAssetsReturned(component, assetsReceived, assets);
emit AsyncWithdrawalExecuted(node, component, assetsReceived);
return assetsReceived;

âŒ Warning: Coverage 41.18% below threshold 70%
```

</details>

### ERC4626Router

**Coverage:** 68.09%
`â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘`

## ğŸ“ˆ Coverage Statistics

| Metric | Value |
|--------|-------|
| Total Functions | 6 |
| Line Coverage | 68.09% |

## âš ï¸ Uncovered Functions

| Index | Function Name | Touched | Reverted | Untouched Lines |
|-------|---------------|---------|----------|----------------|
| 0 | `claim` | false | false | 4 |

## ğŸ” Uncovered Code Lines

### Function: `claim`

```solidity
âŒ Untouched lines:
```

```solidity
INode(node).execute(
```

```solidity
distributor,
```

```solidity
abi.encodeCall(IFluidDistributor.claim, (node, cumulativeAmount, 1, positionId, cycle, merkleProof, ""))
```

```solidity
emit FluidRewardsClaimed(node, cycle, cumulativeAmount);
```

```solidity
âŒ Warning: Coverage 20% below threshold 70%
```


<details>
<summary>ğŸ“Š Full Coverage Report</summary>

```
ğŸ“„ File: routers/FluidRewardsRouter.sol
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ (index)                    â”‚ Values â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ totalFunctions             â”‚ 1      â”‚
â”‚ fullyCoveredFunctions      â”‚ 0      â”‚
â”‚ coveredLines               â”‚ 1      â”‚
â”‚ revertedLines              â”‚ 0      â”‚
â”‚ untouchedLines             â”‚ 4      â”‚
â”‚ functionCoveragePercentage â”‚ 0      â”‚
â”‚ lineCoveragePercentage     â”‚ 20     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”˜

âš ï¸ Not fully covered functions:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ (index) â”‚ functionName â”‚ touched â”‚ reverted â”‚ untouchedLines â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 0       â”‚ 'claim'      â”‚ false   â”‚ false    â”‚ 4              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Function: claim
âŒ Untouched lines:
INode(node).execute(
distributor,
abi.encodeCall(IFluidDistributor.claim, (node, cumulativeAmount, 1, positionId, cycle, merkleProof, ""))
emit FluidRewardsClaimed(node, cycle, cumulativeAmount);

âŒ Warning: Coverage 20% below threshold 70%
```

</details>

### ERC7540Router

**Coverage:** 41.18%
`â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘`

## ğŸ“ˆ Coverage Statistics

| Metric | Value |
|--------|-------|
| Total Functions | 10 |
| Line Coverage | 41.18% |

## âš ï¸ Uncovered Functions

| Index | Function Name | Touched | Reverted | Untouched Lines |
|-------|---------------|---------|----------|----------------|
| 0 | `claim` | false | false | 3 |

## ğŸ” Uncovered Code Lines

### Function: `claim`

```solidity
âŒ Untouched lines:
```

```solidity
INode(node).execute(
```

```solidity
distributor, abi.encodeCall(IIncentraDistributor.claimAll, (node, campaignAddrs, campaignRewards))
```

```solidity
emit IncentraRewardsClaimed(node);
```

```solidity
âŒ Warning: Coverage 25% below threshold 70%
```


<details>
<summary>ğŸ“Š Full Coverage Report</summary>

```
ğŸ“„ File: routers/IncentraRouter.sol
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ (index)                    â”‚ Values â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ totalFunctions             â”‚ 1      â”‚
â”‚ fullyCoveredFunctions      â”‚ 0      â”‚
â”‚ coveredLines               â”‚ 1      â”‚
â”‚ revertedLines              â”‚ 0      â”‚
â”‚ untouchedLines             â”‚ 3      â”‚
â”‚ functionCoveragePercentage â”‚ 0      â”‚
â”‚ lineCoveragePercentage     â”‚ 25     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”˜

âš ï¸ Not fully covered functions:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ (index) â”‚ functionName â”‚ touched â”‚ reverted â”‚ untouchedLines â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 0       â”‚ 'claim'      â”‚ false   â”‚ false    â”‚ 3              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Function: claim
âŒ Untouched lines:
INode(node).execute(
distributor, abi.encodeCall(IIncentraDistributor.claimAll, (node, campaignAddrs, campaignRewards))
emit IncentraRewardsClaimed(node);

âŒ Warning: Coverage 25% below threshold 70%
```

</details>

### FluidRewardsRouter

**Coverage:** 20%
`â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘`

## ğŸ“ˆ Coverage Statistics

| Metric | Value |
|--------|-------|
| Total Functions | 1 |
| Line Coverage | 20% |

## âš ï¸ Uncovered Functions

| Index | Function Name | Touched | Reverted | Untouched Lines |
|-------|---------------|---------|----------|----------------|
| 0 | `claim` | false | false | 4 |

## ğŸ” Uncovered Code Lines

### Function: `claim`

```solidity
âŒ Untouched lines:
```

```solidity
address[] memory users = new address[](tokens.length);
```

```solidity
users[i] = node;
```

```solidity
INode(node).execute(distributor, abi.encodeCall(IMerklDistributor.claim, (users, tokens, amounts, proofs)));
```

```solidity
emit MerklRewardsClaimed(node, tokens, amounts);
```

```solidity
âŒ Warning: Coverage 20% below threshold 70%
```


<details>
<summary>ğŸ“Š Full Coverage Report</summary>

```
ğŸ“„ File: routers/MerklRouter.sol
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ (index)                    â”‚ Values â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ totalFunctions             â”‚ 1      â”‚
â”‚ fullyCoveredFunctions      â”‚ 0      â”‚
â”‚ coveredLines               â”‚ 1      â”‚
â”‚ revertedLines              â”‚ 0      â”‚
â”‚ untouchedLines             â”‚ 4      â”‚
â”‚ functionCoveragePercentage â”‚ 0      â”‚
â”‚ lineCoveragePercentage     â”‚ 20     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”˜

âš ï¸ Not fully covered functions:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ (index) â”‚ functionName â”‚ touched â”‚ reverted â”‚ untouchedLines â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 0       â”‚ 'claim'      â”‚ false   â”‚ false    â”‚ 4              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Function: claim
âŒ Untouched lines:
address[] memory users = new address[](tokens.length);
users[i] = node;
INode(node).execute(distributor, abi.encodeCall(IMerklDistributor.claim, (users, tokens, amounts, proofs)));
emit MerklRewardsClaimed(node, tokens, amounts);

âŒ Warning: Coverage 20% below threshold 70%
```

</details>

### IncentraRouter

**Coverage:** 25%
`â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘`

## ğŸ“ˆ Coverage Statistics

| Metric | Value |
|--------|-------|
| Total Functions | 1 |
| Line Coverage | 25% |

## âš ï¸ Uncovered Functions

| Index | Function Name | Touched | Reverted | Untouched Lines |
|-------|---------------|---------|----------|----------------|
| 0 | `setIncentiveWhitelistStatus` | false | false | 3 |
| 1 | `setExecutorWhitelistStatus` | false | false | 3 |
| 2 | `swap` | true | false | 19 |

## ğŸ” Uncovered Code Lines

### Function: `setIncentiveWhitelistStatus`

```solidity
âŒ Untouched lines:
```

```solidity
if (incentive == address(0)) revert ErrorsLib.ZeroAddress();
```

```solidity
isIncentiveWhitelisted[incentive] = status;
```

```solidity
emit IncentiveWhitelisted(incentive, status);
```

### Function: `setExecutorWhitelistStatus`

```solidity
âŒ Untouched lines:
```

```solidity
if (executor == address(0)) revert ErrorsLib.ZeroAddress();
```

```solidity
isExecutorWhitelisted[executor] = status;
```

```solidity
emit ExecutorWhitelisted(executor, status);
```

### Function: `swap`

```solidity
âŒ Untouched lines:
```

```solidity
address asset = INode(node).asset();
```

```solidity
require(asset != incentive, IncentiveIsAsset());
```

```solidity
require(!INode(node).isComponent(incentive), IncentiveIsComponent());
```

```solidity
require(isIncentiveWhitelisted[incentive], IncentiveNotWhitelisted());
```

```solidity
require(isExecutorWhitelisted[executor], ExecutorNotWhitelisted());
```

```solidity
require(IERC20(incentive).balanceOf(node) >= incentiveAmount, IncentiveInsufficientAmount());
```

```solidity
_safeApprove(node, incentive, ONE_INCH_AGGREGATION_ROUTER_V6, incentiveAmount);
```

```solidity
IAggregationRouterV6.SwapDescription memory swapDescription = IAggregationRouterV6.SwapDescription({
```

```solidity
srcToken: incentive,
```

```solidity
srcReceiver: executor,
```

```solidity
dstReceiver: node,
```

```solidity
minReturnAmount: minAssetsOut,
```

```solidity
flags: 0
```

```solidity
bytes memory result = INode(node).execute(
```

```solidity
ONE_INCH_AGGREGATION_ROUTER_V6,
```

```solidity
(uint256 returnAmount, uint256 spentAmount) = abi.decode(result, (uint256, uint256));
```

```solidity
require(spentAmount == incentiveAmount, IncentiveIncompleteSwap());
```

```solidity
uint256 returnAmountAfterFee = _subtractExecutionFee(returnAmount, node);
```

```solidity
emit Compounded(node, incentive, incentiveAmount, returnAmount, returnAmountAfterFee);
```

```solidity
âŒ Warning: Coverage 19.35% below threshold 70%
```


<details>
<summary>ğŸ“Š Full Coverage Report</summary>

```
ğŸ“„ File: routers/OneInchV6RouterV1.sol
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ (index)                    â”‚ Values â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ totalFunctions             â”‚ 3      â”‚
â”‚ fullyCoveredFunctions      â”‚ 0      â”‚
â”‚ coveredLines               â”‚ 6      â”‚
â”‚ revertedLines              â”‚ 0      â”‚
â”‚ untouchedLines             â”‚ 25     â”‚
â”‚ functionCoveragePercentage â”‚ 0      â”‚
â”‚ lineCoveragePercentage     â”‚ 19.35  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”˜

âš ï¸ Not fully covered functions:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ (index) â”‚ functionName                  â”‚ touched â”‚ reverted â”‚ untouchedLines â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 0       â”‚ 'setIncentiveWhitelistStatus' â”‚ false   â”‚ false    â”‚ 3              â”‚
â”‚ 1       â”‚ 'setExecutorWhitelistStatus'  â”‚ false   â”‚ false    â”‚ 3              â”‚
â”‚ 2       â”‚ 'swap'                        â”‚ true    â”‚ false    â”‚ 19             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Function: setIncentiveWhitelistStatus
âŒ Untouched lines:
if (incentive == address(0)) revert ErrorsLib.ZeroAddress();
isIncentiveWhitelisted[incentive] = status;
emit IncentiveWhitelisted(incentive, status);

Function: setExecutorWhitelistStatus
âŒ Untouched lines:
if (executor == address(0)) revert ErrorsLib.ZeroAddress();
isExecutorWhitelisted[executor] = status;
emit ExecutorWhitelisted(executor, status);

Function: swap
âŒ Untouched lines:
address asset = INode(node).asset();
require(asset != incentive, IncentiveIsAsset());
require(!INode(node).isComponent(incentive), IncentiveIsComponent());
require(isIncentiveWhitelisted[incentive], IncentiveNotWhitelisted());
require(isExecutorWhitelisted[executor], ExecutorNotWhitelisted());
require(IERC20(incentive).balanceOf(node) >= incentiveAmount, IncentiveInsufficientAmount());
_safeApprove(node, incentive, ONE_INCH_AGGREGATION_ROUTER_V6, incentiveAmount);
IAggregationRouterV6.SwapDescription memory swapDescription = IAggregationRouterV6.SwapDescription({
srcToken: incentive,
srcReceiver: executor,
dstReceiver: node,
minReturnAmount: minAssetsOut,
flags: 0
bytes memory result = INode(node).execute(
ONE_INCH_AGGREGATION_ROUTER_V6,
(uint256 returnAmount, uint256 spentAmount) = abi.decode(result, (uint256, uint256));
require(spentAmount == incentiveAmount, IncentiveIncompleteSwap());
uint256 returnAmountAfterFee = _subtractExecutionFee(returnAmount, node);
emit Compounded(node, incentive, incentiveAmount, returnAmount, returnAmountAfterFee);

âŒ Warning: Coverage 19.35% below threshold 70%
```

</details>

### MerklRouter

**Coverage:** 20%
`â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘`

## ğŸ“ˆ Coverage Statistics

| Metric | Value |
|--------|-------|
| Total Functions | 1 |
| Line Coverage | 20% |

<details>
<summary>ğŸ“Š Full Coverage Report</summary>

```
ğŸ“„ File: quoters/QuoterV1.sol
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ (index)                    â”‚ Values â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ totalFunctions             â”‚ 0      â”‚
â”‚ fullyCoveredFunctions      â”‚ 0      â”‚
â”‚ coveredLines               â”‚ 0      â”‚
â”‚ revertedLines              â”‚ 0      â”‚
â”‚ untouchedLines             â”‚ 0      â”‚
â”‚ functionCoveragePercentage â”‚ 0      â”‚
â”‚ lineCoveragePercentage     â”‚ 0      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”˜

âŒ Warning: Coverage 0% below threshold 70%
```

</details>

### OneInchV6RouterV1

**Coverage:** 19.35%
`â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘`

## ğŸ“ˆ Coverage Statistics

| Metric | Value |
|--------|-------|
| Total Functions | 3 |
| Line Coverage | 19.35% |

## âš ï¸ Uncovered Functions

| Index | Function Name | Touched | Reverted | Untouched Lines |
|-------|---------------|---------|----------|----------------|
| 0 | `setBlacklistStatus` | true | false | 2 |
| 1 | `batchSetWhitelistStatus` | false | false | 7 |
| 2 | `setTolerance` | false | false | 2 |
| 3 | `_subtractExecutionFee` | true | false | 3 |

## ğŸ” Uncovered Code Lines

### Function: `setBlacklistStatus`

```solidity
âŒ Untouched lines:
```

```solidity
if (component == address(0)) revert ErrorsLib.ZeroAddress();
```

```solidity
isBlacklisted[component] = status;
```

### Function: `batchSetWhitelistStatus`

```solidity
âŒ Untouched lines:
```

```solidity
if (components.length != statuses.length) revert ErrorsLib.LengthMismatch();
```

```solidity
uint256 length = components.length;
```

```solidity
if (components[i] == address(0)) revert ErrorsLib.ZeroAddress();
```

```solidity
isWhitelisted[components[i]] = statuses[i];
```

```solidity
emit EventsLib.ComponentWhitelisted(components[i], statuses[i]);
```

```solidity
unchecked {
```

```solidity
++i;
```

### Function: `setTolerance`

```solidity
âŒ Untouched lines:
```

```solidity
tolerance = newTolerance;
```

```solidity
emit EventsLib.ToleranceUpdated(newTolerance);
```

### Function: `_subtractExecutionFee`

```solidity
âŒ Untouched lines:
```

```solidity
uint256 transactionAfterFee = transactionAmount - executionFee;
```

```solidity
INode(node).subtractProtocolExecutionFee(executionFee);
```

```solidity
return transactionAfterFee;
```

```solidity
âŒ Warning: Coverage 62.16% below threshold 70%
```


<details>
<summary>ğŸ“Š Full Coverage Report</summary>

```
ğŸ“„ File: libraries/BaseComponentRouter.sol
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ (index)                    â”‚ Values â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ totalFunctions             â”‚ 7      â”‚
â”‚ fullyCoveredFunctions      â”‚ 3      â”‚
â”‚ coveredLines               â”‚ 23     â”‚
â”‚ revertedLines              â”‚ 0      â”‚
â”‚ untouchedLines             â”‚ 14     â”‚
â”‚ functionCoveragePercentage â”‚ 42.86  â”‚
â”‚ lineCoveragePercentage     â”‚ 62.16  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”˜

âš ï¸ Not fully covered functions:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ (index) â”‚ functionName              â”‚ touched â”‚ reverted â”‚ untouchedLines â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 0       â”‚ 'setBlacklistStatus'      â”‚ true    â”‚ false    â”‚ 2              â”‚
â”‚ 1       â”‚ 'batchSetWhitelistStatus' â”‚ false   â”‚ false    â”‚ 7              â”‚
â”‚ 2       â”‚ 'setTolerance'            â”‚ false   â”‚ false    â”‚ 2              â”‚
â”‚ 3       â”‚ '_subtractExecutionFee'   â”‚ true    â”‚ false    â”‚ 3              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Function: setBlacklistStatus
âŒ Untouched lines:
if (component == address(0)) revert ErrorsLib.ZeroAddress();
isBlacklisted[component] = status;

Function: batchSetWhitelistStatus
âŒ Untouched lines:
if (components.length != statuses.length) revert ErrorsLib.LengthMismatch();
uint256 length = components.length;
if (components[i] == address(0)) revert ErrorsLib.ZeroAddress();
isWhitelisted[components[i]] = statuses[i];
emit EventsLib.ComponentWhitelisted(components[i], statuses[i]);
unchecked {
++i;

Function: setTolerance
âŒ Untouched lines:
tolerance = newTolerance;
emit EventsLib.ToleranceUpdated(newTolerance);

Function: _subtractExecutionFee
âŒ Untouched lines:
uint256 transactionAfterFee = transactionAmount - executionFee;
INode(node).subtractProtocolExecutionFee(executionFee);
return transactionAfterFee;

âŒ Warning: Coverage 62.16% below threshold 70%
```

</details>

### QuoterV1

**Coverage:** 0%
`â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘`

## ğŸ“ˆ Coverage Statistics

| Metric | Value |
|--------|-------|
| Total Functions | 0 |
| Line Coverage | 0% |

<details>
<summary>ğŸ“Š Full Coverage Report</summary>

```
ğŸ“„ File: libraries/BaseQuoter.sol
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ (index)                    â”‚ Values â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ totalFunctions             â”‚ 0      â”‚
â”‚ fullyCoveredFunctions      â”‚ 0      â”‚
â”‚ coveredLines               â”‚ 0      â”‚
â”‚ revertedLines              â”‚ 0      â”‚
â”‚ untouchedLines             â”‚ 0      â”‚
â”‚ functionCoveragePercentage â”‚ 0      â”‚
â”‚ lineCoveragePercentage     â”‚ 0      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”˜

âŒ Warning: Coverage 0% below threshold 70%
```

</details>

### BaseComponentRouter

**Coverage:** 62.16%
`â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘`

## ğŸ“ˆ Coverage Statistics

| Metric | Value |
|--------|-------|
| Total Functions | 7 |
| Line Coverage | 62.16% |

<details>
<summary>ğŸ“Š Full Coverage Report</summary>

```
ğŸ“„ File: libraries/ErrorsLib.sol
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ (index)                    â”‚ Values â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ totalFunctions             â”‚ 0      â”‚
â”‚ fullyCoveredFunctions      â”‚ 0      â”‚
â”‚ coveredLines               â”‚ 0      â”‚
â”‚ revertedLines              â”‚ 0      â”‚
â”‚ untouchedLines             â”‚ 0      â”‚
â”‚ functionCoveragePercentage â”‚ 0      â”‚
â”‚ lineCoveragePercentage     â”‚ 0      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”˜

âŒ Warning: Coverage 0% below threshold 70%
```

</details>

### BaseQuoter

**Coverage:** 0%
`â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘`

## ğŸ“ˆ Coverage Statistics

| Metric | Value |
|--------|-------|
| Total Functions | 0 |
| Line Coverage | 0% |

<details>
<summary>ğŸ“Š Full Coverage Report</summary>

```
ğŸ“„ File: libraries/EventsLib.sol
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ (index)                    â”‚ Values â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ totalFunctions             â”‚ 0      â”‚
â”‚ fullyCoveredFunctions      â”‚ 0      â”‚
â”‚ coveredLines               â”‚ 0      â”‚
â”‚ revertedLines              â”‚ 0      â”‚
â”‚ untouchedLines             â”‚ 0      â”‚
â”‚ functionCoveragePercentage â”‚ 0      â”‚
â”‚ lineCoveragePercentage     â”‚ 0      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”˜

âŒ Warning: Coverage 0% below threshold 70%
```

</details>

### ErrorsLib

**Coverage:** 0%
`â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘`

## ğŸ“ˆ Coverage Statistics

| Metric | Value |
|--------|-------|
| Total Functions | 0 |
| Line Coverage | 0% |

<details>
<summary>ğŸ“Š Full Coverage Report</summary>

```
ğŸ“„ File: libraries/MathLib.sol
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ (index)                    â”‚ Values â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ totalFunctions             â”‚ 0      â”‚
â”‚ fullyCoveredFunctions      â”‚ 0      â”‚
â”‚ coveredLines               â”‚ 0      â”‚
â”‚ revertedLines              â”‚ 0      â”‚
â”‚ untouchedLines             â”‚ 0      â”‚
â”‚ functionCoveragePercentage â”‚ 0      â”‚
â”‚ lineCoveragePercentage     â”‚ 0      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”˜

âŒ Warning: Coverage 0% below threshold 70%
```

</details>

### EventsLib

**Coverage:** 0%
`â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘`

## ğŸ“ˆ Coverage Statistics

| Metric | Value |
|--------|-------|
| Total Functions | 0 |
| Line Coverage | 0% |

<details>
<summary>ğŸ“Š Full Coverage Report</summary>

```
ğŸ“„ File: libraries/RegistryAccessControl.sol
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ (index)                    â”‚ Values â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ totalFunctions             â”‚ 0      â”‚
â”‚ fullyCoveredFunctions      â”‚ 0      â”‚
â”‚ coveredLines               â”‚ 0      â”‚
â”‚ revertedLines              â”‚ 0      â”‚
â”‚ untouchedLines             â”‚ 0      â”‚
â”‚ functionCoveragePercentage â”‚ 0      â”‚
â”‚ lineCoveragePercentage     â”‚ 0      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”˜

âŒ Warning: Coverage 0% below threshold 70%
```

</details>

### MathLib

**Coverage:** 0%
`â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘`

## ğŸ“ˆ Coverage Statistics

| Metric | Value |
|--------|-------|
| Total Functions | 0 |
| Line Coverage | 0% |

## âš ï¸ Uncovered Functions

| Index | Function Name | Touched | Reverted | Untouched Lines |
|-------|---------------|---------|----------|----------------|
| 0 | `setPriceDeviation` | false | false | 3 |
| 1 | `setSettlementDeviation` | false | false | 3 |
| 2 | `setPriceUpdateDeviation` | false | false | 2 |
| 3 | `setMinDepositAmount` | false | false | 2 |
| 4 | `setMinRedeemAmount` | false | false | 2 |
| 5 | `forceUpdateLastPrice` | false | false | 3 |
| 6 | `updateLastPrice` | false | false | 3 |
| 7 | `requestDeposit` | true | false | 1 |
| 8 | `settleDeposit` | true | false | 18 |
| 9 | `mint` | true | false | 9 |
| 10 | `requestRedeem` | true | false | 4 |
| 11 | `settleRedeem` | true | false | 25 |
| 12 | `withdraw` | false | false | 12 |
| 13 | `forwardRequestsToDigift` | true | false | 5 |
| 14 | `deposit` | false | false | 1 |
| 15 | `deposit` | false | false | 1 |
| 16 | `mint` | false | false | 1 |
| 17 | `redeem` | false | false | 1 |
| 18 | `setOperator` | false | false | 1 |

## ğŸ” Uncovered Code Lines

### Function: `setPriceDeviation`

```solidity
âŒ Untouched lines:
```

```solidity
require(value <= WAD, InvalidPercentage());
```

```solidity
emit PriceDeviationChange(priceDeviation, value);
```

```solidity
priceDeviation = value;
```

### Function: `setSettlementDeviation`

```solidity
âŒ Untouched lines:
```

```solidity
require(value <= WAD, InvalidPercentage());
```

```solidity
emit SettlementDeviationChange(settlementDeviation, value);
```

```solidity
settlementDeviation = value;
```

### Function: `setPriceUpdateDeviation`

```solidity
âŒ Untouched lines:
```

```solidity
emit PriceUpdateDeviationChange(priceUpdateDeviation, value);
```

```solidity
priceUpdateDeviation = value;
```

### Function: `setMinDepositAmount`

```solidity
âŒ Untouched lines:
```

```solidity
emit MinDepositAmountChange(minDepositAmount, value);
```

```solidity
minDepositAmount = value;
```

### Function: `setMinRedeemAmount`

```solidity
âŒ Untouched lines:
```

```solidity
emit MinRedeemAmountChange(minRedeemAmount, value);
```

```solidity
minRedeemAmount = value;
```

### Function: `forceUpdateLastPrice`

```solidity
âŒ Untouched lines:
```

```solidity
uint256 price = dFeedPriceOracle.getPrice();
```

```solidity
lastPrice = price;
```

```solidity
emit LastPriceUpdate(price);
```

### Function: `updateLastPrice`

```solidity
âŒ Untouched lines:
```

```solidity
uint256 price = _getPrice();
```

```solidity
lastPrice = price;
```

```solidity
emit LastPriceUpdate(price);
```

### Function: `requestDeposit`

```solidity
âŒ Untouched lines:
```

```solidity
return REQUEST_ID;
```

### Function: `settleDeposit`

```solidity
âŒ Untouched lines:
```

```solidity
require(
```

```solidity
MathLib.withinRange(vars.globalPendingDepositRequest, vars.settlementValue, settlementDeviation),
```

```solidity
NodeState storage node = _nodeState[nodes[i]];
```

```solidity
uint256 nodePendingDepositRequest = node.pendingDepositRequest;
```

```solidity
require(nodePendingDepositRequest > 0, NoPendingDepositRequest(nodes[i]));
```

```solidity
uint256 assetsToReimburse = nodePendingDepositRequest.mulDiv(assets, vars.globalPendingDepositRequest);
```

```solidity
uint256 sharesToMint = nodePendingDepositRequest.mulDiv(shares, vars.globalPendingDepositRequest);
```

```solidity
vars.totalPendingDepositRequestCheck += nodePendingDepositRequest;
```

```solidity
vars.totalSharesToMint += sharesToMint;
```

```solidity
vars.totalAssetsToReimburse += assetsToReimburse;
```

```solidity
if (vars.totalSharesToMint < shares
```

```solidity
sharesToMint += shares - vars.totalSharesToMint;
```

```solidity
assetsToReimburse += assets - vars.totalAssetsToReimburse;
```

```solidity
node.claimableDepositRequest = nodePendingDepositRequest;
```

```solidity
node.pendingDepositRequest = 0;
```

```solidity
node.maxMint = sharesToMint;
```

```solidity
node.pendingDepositReimbursement = assetsToReimburse;
```

```solidity
emit DepositSettled(nodes[i], sharesToMint, assetsToReimburse);
```

### Function: `mint`

```solidity
âŒ Untouched lines:
```

```solidity
require(node.maxMint == shares, MintAllSharesOnly());
```

```solidity
assets = node.claimableDepositRequest;
```

```solidity
uint256 assetsToReimburse = node.pendingDepositReimbursement;
```

```solidity
node.claimableDepositRequest = 0;
```

```solidity
node.maxMint = 0;
```

```solidity
node.pendingDepositReimbursement = 0;
```

```solidity
_mint(msg.sender, shares);
```

```solidity
IERC20(asset).safeTransfer(msg.sender, assetsToReimburse);
```

```solidity
emit Deposit(controller, receiver, assets - assetsToReimburse, shares);
```

### Function: `requestRedeem`

```solidity
âŒ Untouched lines:
```

```solidity
_nodeState[msg.sender].pendingRedeemRequest = shares;
```

```solidity
_globalState.accumulatedRedemption += shares;
```

```solidity
_spendAllowance(msg.sender, address(this), shares);
```

```solidity
_transfer(msg.sender, address(this), shares);
```

### Function: `settleRedeem`

```solidity
âŒ Untouched lines:
```

```solidity
(uint256 shares, uint256 assets) = digiftEventVerifier.verifySettlementEvent(
```

```solidity
verifyArgs,
```

```solidity
DigiftEventVerifier.EventType.REDEEM, address(subRedManagement), stToken, asset
```

```solidity
SettleRedeemVars memory vars;
```

```solidity
vars.globalPendingRedeemRequest = _globalState.pendingRedeemRequest;
```

```solidity
vars.settlementValue = convertToShares(assets) + shares;
```

```solidity
require(vars.globalPendingRedeemRequest > 0, NothingToSettle());
```

```solidity
require(
```

```solidity
MathLib.withinRange(vars.globalPendingRedeemRequest, vars.settlementValue, settlementDeviation),
```

```solidity
NodeState storage node = _nodeState[nodes[i]];
```

```solidity
uint256 nodePendingRedeemRequest = node.pendingRedeemRequest;
```

```solidity
require(nodePendingRedeemRequest > 0, NoPendingRedeemRequest(nodes[i]));
```

```solidity
uint256 assetsToReturn = nodePendingRedeemRequest.mulDiv(assets, vars.globalPendingRedeemRequest);
```

```solidity
uint256 sharesToReimburse = nodePendingRedeemRequest.mulDiv(shares, vars.globalPendingRedeemRequest);
```

```solidity
vars.totalPendingRedeemRequestCheck += nodePendingRedeemRequest;
```

```solidity
vars.totalAssetsToReturn += assetsToReturn;
```

```solidity
vars.totalSharesToReimburse += sharesToReimburse;
```

```solidity
if (vars.totalAssetsToReturn < assets
```

```solidity
assetsToReturn += assets - vars.totalAssetsToReturn;
```

```solidity
sharesToReimburse += shares - vars.totalSharesToReimburse;
```

```solidity
node.claimableRedeemRequest = nodePendingRedeemRequest;
```

```solidity
node.pendingRedeemRequest = 0;
```

```solidity
node.maxWithdraw = assetsToReturn;
```

```solidity
node.pendingRedeemReimbursement = sharesToReimburse;
```

```solidity
emit RedeemSettled(nodes[i], sharesToReimburse, assetsToReturn);
```

### Function: `withdraw`

```solidity
âŒ Untouched lines:
```

```solidity
require(_nodeState[msg.sender].claimableRedeemRequest > 0, RedeemRequestNotFulfilled());
```

```solidity
require(_nodeState[msg.sender].maxWithdraw == assets, WithdrawAllAssetsOnly());
```

```solidity
shares = _nodeState[msg.sender].claimableRedeemRequest;
```

```solidity
uint256 sharesToReimburse = _nodeState[msg.sender].pendingRedeemReimbursement;
```

```solidity
uint256 sharesToBurn = shares - sharesToReimburse;
```

```solidity
_nodeState[msg.sender].claimableRedeemRequest = 0;
```

```solidity
_nodeState[msg.sender].maxWithdraw = 0;
```

```solidity
_nodeState[msg.sender].pendingRedeemReimbursement = 0;
```

```solidity
_burn(address(this), sharesToBurn);
```

```solidity
_transfer(address(this), msg.sender, sharesToReimburse);
```

```solidity
IERC20(asset).safeTransfer(msg.sender, assets);
```

```solidity
emit Withdraw(msg.sender, receiver, controller, assets, shares - sharesToReimburse);
```

### Function: `forwardRequestsToDigift`

```solidity
âŒ Untouched lines:
```

```solidity
_globalState.accumulatedRedemption = 0;
```

```solidity
_globalState.pendingRedeemRequest = pendingShares;
```

```solidity
IERC20(stToken).safeIncreaseAllowance(address(subRedManagement), pendingShares);
```

```solidity
subRedManagement.redeem(stToken, asset, pendingShares, block.timestamp + 1);
```

```solidity
emit DigiftRedeemed(pendingShares);
```

### Function: `deposit`

```solidity
âŒ Untouched lines:
```

```solidity
revert Unsupported();
```

### Function: `deposit`

```solidity
âŒ Untouched lines:
```

```solidity
revert Unsupported();
```

### Function: `mint`

```solidity
âŒ Untouched lines:
```

```solidity
revert Unsupported();
```

### Function: `redeem`

```solidity
âŒ Untouched lines:
```

```solidity
revert Unsupported();
```

### Function: `setOperator`

```solidity
âŒ Untouched lines:
```

```solidity
revert Unsupported();
```

```solidity
âŒ Warning: Coverage 42.94% below threshold 70%
```


<details>
<summary>ğŸ“Š Full Coverage Report</summary>

```
ğŸ“„ File: digift/DigiftAdapter.sol
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ (index)                    â”‚ Values â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ totalFunctions             â”‚ 22     â”‚
â”‚ fullyCoveredFunctions      â”‚ 3      â”‚
â”‚ coveredLines               â”‚ 73     â”‚
â”‚ revertedLines              â”‚ 0      â”‚
â”‚ untouchedLines             â”‚ 97     â”‚
â”‚ functionCoveragePercentage â”‚ 13.64  â”‚
â”‚ lineCoveragePercentage     â”‚ 42.94  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”˜

âš ï¸ Not fully covered functions:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ (index) â”‚ functionName              â”‚ touched â”‚ reverted â”‚ untouchedLines â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 0       â”‚ 'setPriceDeviation'       â”‚ false   â”‚ false    â”‚ 3              â”‚
â”‚ 1       â”‚ 'setSettlementDeviation'  â”‚ false   â”‚ false    â”‚ 3              â”‚
â”‚ 2       â”‚ 'setPriceUpdateDeviation' â”‚ false   â”‚ false    â”‚ 2              â”‚
â”‚ 3       â”‚ 'setMinDepositAmount'     â”‚ false   â”‚ false    â”‚ 2              â”‚
â”‚ 4       â”‚ 'setMinRedeemAmount'      â”‚ false   â”‚ false    â”‚ 2              â”‚
â”‚ 5       â”‚ 'forceUpdateLastPrice'    â”‚ false   â”‚ false    â”‚ 3              â”‚
â”‚ 6       â”‚ 'updateLastPrice'         â”‚ false   â”‚ false    â”‚ 3              â”‚
â”‚ 7       â”‚ 'requestDeposit'          â”‚ true    â”‚ false    â”‚ 1              â”‚
â”‚ 8       â”‚ 'settleDeposit'           â”‚ true    â”‚ false    â”‚ 18             â”‚
â”‚ 9       â”‚ 'mint'                    â”‚ true    â”‚ false    â”‚ 9              â”‚
â”‚ 10      â”‚ 'requestRedeem'           â”‚ true    â”‚ false    â”‚ 4              â”‚
â”‚ 11      â”‚ 'settleRedeem'            â”‚ true    â”‚ false    â”‚ 25             â”‚
â”‚ 12      â”‚ 'withdraw'                â”‚ false   â”‚ false    â”‚ 12             â”‚
â”‚ 13      â”‚ 'forwardRequestsToDigift' â”‚ true    â”‚ false    â”‚ 5              â”‚
â”‚ 14      â”‚ 'deposit'                 â”‚ false   â”‚ false    â”‚ 1              â”‚
â”‚ 15      â”‚ 'deposit'                 â”‚ false   â”‚ false    â”‚ 1              â”‚
â”‚ 16      â”‚ 'mint'                    â”‚ false   â”‚ false    â”‚ 1              â”‚
â”‚ 17      â”‚ 'redeem'                  â”‚ false   â”‚ false    â”‚ 1              â”‚
â”‚ 18      â”‚ 'setOperator'             â”‚ false   â”‚ false    â”‚ 1              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Function: setPriceDeviation
âŒ Untouched lines:
require(value <= WAD, InvalidPercentage());
emit PriceDeviationChange(priceDeviation, value);
priceDeviation = value;

Function: setSettlementDeviation
âŒ Untouched lines:
require(value <= WAD, InvalidPercentage());
emit SettlementDeviationChange(settlementDeviation, value);
settlementDeviation = value;

Function: setPriceUpdateDeviation
âŒ Untouched lines:
emit PriceUpdateDeviationChange(priceUpdateDeviation, value);
priceUpdateDeviation = value;

Function: setMinDepositAmount
âŒ Untouched lines:
emit MinDepositAmountChange(minDepositAmount, value);
minDepositAmount = value;

Function: setMinRedeemAmount
âŒ Untouched lines:
emit MinRedeemAmountChange(minRedeemAmount, value);
minRedeemAmount = value;

Function: forceUpdateLastPrice
âŒ Untouched lines:
uint256 price = dFeedPriceOracle.getPrice();
lastPrice = price;
emit LastPriceUpdate(price);

Function: updateLastPrice
âŒ Untouched lines:
uint256 price = _getPrice();
lastPrice = price;
emit LastPriceUpdate(price);

Function: requestDeposit
âŒ Untouched lines:
return REQUEST_ID;

Function: settleDeposit
âŒ Untouched lines:
require(
MathLib.withinRange(vars.globalPendingDepositRequest, vars.settlementValue, settlementDeviation),
NodeState storage node = _nodeState[nodes[i]];
uint256 nodePendingDepositRequest = node.pendingDepositRequest;
require(nodePendingDepositRequest > 0, NoPendingDepositRequest(nodes[i]));
uint256 assetsToReimburse = nodePendingDepositRequest.mulDiv(assets, vars.globalPendingDepositRequest);
uint256 sharesToMint = nodePendingDepositRequest.mulDiv(shares, vars.globalPendingDepositRequest);
vars.totalPendingDepositRequestCheck += nodePendingDepositRequest;
vars.totalSharesToMint += sharesToMint;
vars.totalAssetsToReimburse += assetsToReimburse;
if (vars.totalSharesToMint < shares
sharesToMint += shares - vars.totalSharesToMint;
assetsToReimburse += assets - vars.totalAssetsToReimburse;
node.claimableDepositRequest = nodePendingDepositRequest;
node.pendingDepositRequest = 0;
node.maxMint = sharesToMint;
node.pendingDepositReimbursement = assetsToReimburse;
emit DepositSettled(nodes[i], sharesToMint, assetsToReimburse);

Function: mint
âŒ Untouched lines:
require(node.maxMint == shares, MintAllSharesOnly());
assets = node.claimableDepositRequest;
uint256 assetsToReimburse = node.pendingDepositReimbursement;
node.claimableDepositRequest = 0;
node.maxMint = 0;
node.pendingDepositReimbursement = 0;
_mint(msg.sender, shares);
IERC20(asset).safeTransfer(msg.sender, assetsToReimburse);
emit Deposit(controller, receiver, assets - assetsToReimburse, shares);

Function: requestRedeem
âŒ Untouched lines:
_nodeState[msg.sender].pendingRedeemRequest = shares;
_globalState.accumulatedRedemption += shares;
_spendAllowance(msg.sender, address(this), shares);
_transfer(msg.sender, address(this), shares);

Function: settleRedeem
âŒ Untouched lines:
(uint256 shares, uint256 assets) = digiftEventVerifier.verifySettlementEvent(
verifyArgs,
DigiftEventVerifier.EventType.REDEEM, address(subRedManagement), stToken, asset
SettleRedeemVars memory vars;
vars.globalPendingRedeemRequest = _globalState.pendingRedeemRequest;
vars.settlementValue = convertToShares(assets) + shares;
require(vars.globalPendingRedeemRequest > 0, NothingToSettle());
require(
MathLib.withinRange(vars.globalPendingRedeemRequest, vars.settlementValue, settlementDeviation),
NodeState storage node = _nodeState[nodes[i]];
uint256 nodePendingRedeemRequest = node.pendingRedeemRequest;
require(nodePendingRedeemRequest > 0, NoPendingRedeemRequest(nodes[i]));
uint256 assetsToReturn = nodePendingRedeemRequest.mulDiv(assets, vars.globalPendingRedeemRequest);
uint256 sharesToReimburse = nodePendingRedeemRequest.mulDiv(shares, vars.globalPendingRedeemRequest);
vars.totalPendingRedeemRequestCheck += nodePendingRedeemRequest;
vars.totalAssetsToReturn += assetsToReturn;
vars.totalSharesToReimburse += sharesToReimburse;
if (vars.totalAssetsToReturn < assets
assetsToReturn += assets - vars.totalAssetsToReturn;
sharesToReimburse += shares - vars.totalSharesToReimburse;
node.claimableRedeemRequest = nodePendingRedeemRequest;
node.pendingRedeemRequest = 0;
node.maxWithdraw = assetsToReturn;
node.pendingRedeemReimbursement = sharesToReimburse;
emit RedeemSettled(nodes[i], sharesToReimburse, assetsToReturn);

Function: withdraw
âŒ Untouched lines:
require(_nodeState[msg.sender].claimableRedeemRequest > 0, RedeemRequestNotFulfilled());
require(_nodeState[msg.sender].maxWithdraw == assets, WithdrawAllAssetsOnly());
shares = _nodeState[msg.sender].claimableRedeemRequest;
uint256 sharesToReimburse = _nodeState[msg.sender].pendingRedeemReimbursement;
uint256 sharesToBurn = shares - sharesToReimburse;
_nodeState[msg.sender].claimableRedeemRequest = 0;
_nodeState[msg.sender].maxWithdraw = 0;
_nodeState[msg.sender].pendingRedeemReimbursement = 0;
_burn(address(this), sharesToBurn);
_transfer(address(this), msg.sender, sharesToReimburse);
IERC20(asset).safeTransfer(msg.sender, assets);
emit Withdraw(msg.sender, receiver, controller, assets, shares - sharesToReimburse);

Function: forwardRequestsToDigift
âŒ Untouched lines:
_globalState.accumulatedRedemption = 0;
_globalState.pendingRedeemRequest = pendingShares;
IERC20(stToken).safeIncreaseAllowance(address(subRedManagement), pendingShares);
subRedManagement.redeem(stToken, asset, pendingShares, block.timestamp + 1);
emit DigiftRedeemed(pendingShares);

Function: deposit
âŒ Untouched lines:
revert Unsupported();

Function: deposit
âŒ Untouched lines:
revert Unsupported();

Function: mint
âŒ Untouched lines:
revert Unsupported();

Function: redeem
âŒ Untouched lines:
revert Unsupported();

Function: setOperator
âŒ Untouched lines:
revert Unsupported();

âŒ Warning: Coverage 42.94% below threshold 70%
```

</details>

### RegistryAccessControl

**Coverage:** 0%
`â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘`

## ğŸ“ˆ Coverage Statistics

| Metric | Value |
|--------|-------|
| Total Functions | 0 |
| Line Coverage | 0% |

## âš ï¸ Uncovered Functions

| Index | Function Name | Touched | Reverted | Untouched Lines |
|-------|---------------|---------|----------|----------------|
| 0 | `setWhitelist` | false | false | 2 |
| 1 | `setBlockHash` | false | false | 2 |
| 2 | `verifySettlementEvent` | true | false | 27 |
| 3 | `_getBlockHash` | false | false | 4 |

## ğŸ” Uncovered Code Lines

### Function: `setWhitelist`

```solidity
âŒ Untouched lines:
```

```solidity
whitelist[digiftAdapter] = status;
```

```solidity
emit WhitelistChange(digiftAdapter, status);
```

### Function: `setBlockHash`

```solidity
âŒ Untouched lines:
```

```solidity
blockHashes[blockNumber] = blockHash;
```

```solidity
emit BlockHashSet(blockNumber, blockHash);
```

### Function: `verifySettlementEvent`

```solidity
âŒ Untouched lines:
```

```solidity
require(whitelist[msg.sender], NotWhitelisted());
```

```solidity
Vars memory vars;
```

```solidity
vars.blockHash = keccak256(fargs.headerRlp);
```

```solidity
vars.eventSignature = nargs.eventType == EventType.SUBSCRIBE ? SETTLE_SUBSCRIBER_TOPIC : SETTLE_REDEMPTION_TOPIC;
```

```solidity
if (_getBlockHash(fargs.blockNumber) != vars.blockHash) revert BadHeader();
```

```solidity
vars.receiptsRoot = bytes32(RLPReader.readBytes(RLPReader.readList(fargs.headerRlp)[5]));
```

```solidity
vars.logs = RLPReader.readList(
```

```solidity
RLPReader.readList(_stripTypedPrefix(MerkleTrie.get(fargs.txIndex, fargs.proof, vars.receiptsRoot)))[3]
```

```solidity
vars.log = RLPReader.readList(vars.logs[i]);
```

```solidity
if (address(bytes20(RLPReader.readBytes(vars.log[0]))) != nargs.emittingAddress) continue;
```

```solidity
RLPReader.RLPItem[] memory topics = RLPReader.readList(vars.log[1]);
```

```solidity
if (bytes32(RLPReader.readBytes(topics[0])) != vars.eventSignature) continue;
```

```solidity
address stToken,
```

```solidity
RLPReader.readBytes(vars.log[2]), (address, address[], uint256[], address[], uint256[], uint256[])
```

```solidity
if (stToken != nargs.securityToken) continue;
```

```solidity
vars.investorIndex = type(uint256).max;
```

```solidity
vars.investorIndex = j;
```

```solidity
break;
```

```solidity
if (vars.investorIndex == type(uint256).max) continue; // Caller not in investor list
```

```solidity
if (currencyTokenList[vars.investorIndex] != nargs.currencyToken) continue;
```

```solidity
vars.logHash = _hashLog(vars.blockHash, vars.receiptsRoot, fargs.txIndex, i);
```

```solidity
if (usedLogs[vars.logHash]) revert LogAlreadyUsed();
```

```solidity
usedLogs[vars.logHash] = true;
```

```solidity
emit Verified(
```

```solidity
msg.sender,
```

```solidity
return (quantityList[vars.investorIndex], amountList[vars.investorIndex]);
```

```solidity
revert NoEvent();
```

### Function: `_getBlockHash`

```solidity
âŒ Untouched lines:
```

```solidity
bytes32 blockHash = blockhash(blockNumber);
```

```solidity
blockHash = blockHashes[blockNumber];
```

```solidity
if (blockHash == 0) revert MissedWindow();
```

```solidity
return blockHash;
```

```solidity
âŒ Warning: Coverage 30% below threshold 70%
```


<details>
<summary>ğŸ“Š Full Coverage Report</summary>

```
ğŸ“„ File: digift/DigiftEventVerifier.sol
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ (index)                    â”‚ Values â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ totalFunctions             â”‚ 4      â”‚
â”‚ fullyCoveredFunctions      â”‚ 0      â”‚
â”‚ coveredLines               â”‚ 15     â”‚
â”‚ revertedLines              â”‚ 0      â”‚
â”‚ untouchedLines             â”‚ 35     â”‚
â”‚ functionCoveragePercentage â”‚ 0      â”‚
â”‚ lineCoveragePercentage     â”‚ 30     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”˜

âš ï¸ Not fully covered functions:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ (index) â”‚ functionName            â”‚ touched â”‚ reverted â”‚ untouchedLines â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 0       â”‚ 'setWhitelist'          â”‚ false   â”‚ false    â”‚ 2              â”‚
â”‚ 1       â”‚ 'setBlockHash'          â”‚ false   â”‚ false    â”‚ 2              â”‚
â”‚ 2       â”‚ 'verifySettlementEvent' â”‚ true    â”‚ false    â”‚ 27             â”‚
â”‚ 3       â”‚ '_getBlockHash'         â”‚ false   â”‚ false    â”‚ 4              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Function: setWhitelist
âŒ Untouched lines:
whitelist[digiftAdapter] = status;
emit WhitelistChange(digiftAdapter, status);

Function: setBlockHash
âŒ Untouched lines:
blockHashes[blockNumber] = blockHash;
emit BlockHashSet(blockNumber, blockHash);

Function: verifySettlementEvent
âŒ Untouched lines:
require(whitelist[msg.sender], NotWhitelisted());
Vars memory vars;
vars.blockHash = keccak256(fargs.headerRlp);
vars.eventSignature = nargs.eventType == EventType.SUBSCRIBE ? SETTLE_SUBSCRIBER_TOPIC : SETTLE_REDEMPTION_TOPIC;
if (_getBlockHash(fargs.blockNumber) != vars.blockHash) revert BadHeader();
vars.receiptsRoot = bytes32(RLPReader.readBytes(RLPReader.readList(fargs.headerRlp)[5]));
vars.logs = RLPReader.readList(
RLPReader.readList(_stripTypedPrefix(MerkleTrie.get(fargs.txIndex, fargs.proof, vars.receiptsRoot)))[3]
vars.log = RLPReader.readList(vars.logs[i]);
if (address(bytes20(RLPReader.readBytes(vars.log[0]))) != nargs.emittingAddress) continue;
RLPReader.RLPItem[] memory topics = RLPReader.readList(vars.log[1]);
if (bytes32(RLPReader.readBytes(topics[0])) != vars.eventSignature) continue;
address stToken,
RLPReader.readBytes(vars.log[2]), (address, address[], uint256[], address[], uint256[], uint256[])
if (stToken != nargs.securityToken) continue;
vars.investorIndex = type(uint256).max;
vars.investorIndex = j;
break;
if (vars.investorIndex == type(uint256).max) continue; // Caller not in investor list
if (currencyTokenList[vars.investorIndex] != nargs.currencyToken) continue;
vars.logHash = _hashLog(vars.blockHash, vars.receiptsRoot, fargs.txIndex, i);
if (usedLogs[vars.logHash]) revert LogAlreadyUsed();
usedLogs[vars.logHash] = true;
emit Verified(
msg.sender,
return (quantityList[vars.investorIndex], amountList[vars.investorIndex]);
revert NoEvent();

Function: _getBlockHash
âŒ Untouched lines:
bytes32 blockHash = blockhash(blockNumber);
blockHash = blockHashes[blockNumber];
if (blockHash == 0) revert MissedWindow();
return blockHash;

âŒ Warning: Coverage 30% below threshold 70%
```

</details>

### DigiftAdapter

**Coverage:** 42.94%
`â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘`

## ğŸ“ˆ Coverage Statistics

| Metric | Value |
|--------|-------|
| Total Functions | 22 |
| Line Coverage | 42.94% |

### DigiftAdapterFactory

**Coverage:** 100%
`â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ`

## ğŸ“ˆ Coverage Statistics

| Metric | Value |
|--------|-------|
| Total Functions | 1 |
| Line Coverage | 100% |

### DigiftEventVerifier

**Coverage:** 30%
`â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘`

## ğŸ“ˆ Coverage Statistics

| Metric | Value |
|--------|-------|
| Total Functions | 4 |
| Line Coverage | 30% |

## ğŸ’¡ Recommendations

The following contracts need attention to meet the 70% coverage threshold:

- **Escrow**: Needs 70% improvement (current: 0%)
- **Node**: Needs 2.34% improvement (current: 67.66%)
- **ERC4626Router**: Needs 1.91% improvement (current: 68.09%)
- **ERC7540Router**: Needs 28.82% improvement (current: 41.18%)
- **FluidRewardsRouter**: Needs 50% improvement (current: 20%)
- **IncentraRouter**: Needs 45% improvement (current: 25%)
- **MerklRouter**: Needs 50% improvement (current: 20%)
- **OneInchV6RouterV1**: Needs 50.65% improvement (current: 19.35%)
- **QuoterV1**: Needs 70% improvement (current: 0%)
- **BaseComponentRouter**: Needs 7.84% improvement (current: 62.16%)
- **BaseQuoter**: Needs 70% improvement (current: 0%)
- **ErrorsLib**: Needs 70% improvement (current: 0%)
- **EventsLib**: Needs 70% improvement (current: 0%)
- **MathLib**: Needs 70% improvement (current: 0%)
- **RegistryAccessControl**: Needs 70% improvement (current: 0%)
- **DigiftAdapter**: Needs 27.06% improvement (current: 42.94%)
- **DigiftEventVerifier**: Needs 40% improvement (current: 30%)

### Next Steps:
1. Focus on contracts with coverage below 30% first
2. Add test cases for uncovered functions
3. Review and test edge cases
4. Run echidna with longer campaign for better coverage

---
*Report generated by echidna-coverage-analyzer.sh*
