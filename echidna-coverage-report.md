# Echidna Coverage Report

**Generated:** 2025-11-03 15:48:53
**Coverage File:** `echidna-corpus/covered.1762181067.txt`
**Timestamp:** 1762181067

## ğŸ“Š Overall Summary

| Metric | Value |
|--------|-------|
| **Total Contracts** | 20 |
| **Contracts Below 70%** | 17 |
| **Overall Line Coverage** | 6.31% |
| **Total Lines** | 5147 |
| **Covered Lines** | 325 |

âš ï¸ **Status:** 17 contract(s) below 70% coverage threshold

## ğŸ” Coverage Analysis Against Scope

âœ… All contracts in scope have coverage data.

## ğŸ“‹ Contracts Coverage by Package

### ğŸ“¦ Package:  src

| Contract | Coverage | Status | Functions | Details |
|----------|----------|--------|-----------|---------|
| ğŸ”´ **Escrow** | 0% | âŒ Fail | 0 | [View](#escrow) |
| ğŸŸ¡ **Node** | 65.06% | âŒ Fail | 45 | [View](#node) |
| ğŸŸ¢ **NodeFactory** | 75% | âœ… Pass | 1 | [View](#nodefactory) |
| ğŸŸ¢ **NodeRegistry** | 93.48% | âœ… Pass | 13 | [View](#noderegistry) |
| ğŸ”´ **ERC4626Router** | 14.29% | âŒ Fail | 6 | [View](#erc4626router) |
| ğŸ”´ **ERC7540Router** | 16.42% | âŒ Fail | 10 | [View](#erc7540router) |
| ğŸ”´ **FluidRewardsRouter** | 20% | âŒ Fail | 1 | [View](#fluidrewardsrouter) |
| ğŸ”´ **IncentraRouter** | 25% | âŒ Fail | 1 | [View](#incentrarouter) |
| ğŸ”´ **MerklRouter** | 20% | âŒ Fail | 1 | [View](#merklrouter) |
| ğŸ”´ **OneInchV6RouterV1** | 19.35% | âŒ Fail | 3 | [View](#oneinchv6routerv1) |
| ğŸ”´ **QuoterV1** | 0% | âŒ Fail | 0 | [View](#quoterv1) |
| ğŸŸ  **BaseComponentRouter** | 31.43% | âŒ Fail | 7 | [View](#basecomponentrouter) |
| ğŸ”´ **BaseQuoter** | 0% | âŒ Fail | 0 | [View](#basequoter) |
| ğŸ”´ **ErrorsLib** | 0% | âŒ Fail | 0 | [View](#errorslib) |
| ğŸ”´ **EventsLib** | 0% | âŒ Fail | 0 | [View](#eventslib) |
| ğŸ”´ **MathLib** | 0% | âŒ Fail | 0 | [View](#mathlib) |
| ğŸ”´ **RegistryAccessControl** | 0% | âŒ Fail | 0 | [View](#registryaccesscontrol) |
| ğŸ”´ **DigiftAdapter** | 27.98% | âŒ Fail | 22 | [View](#digiftadapter) |
| ğŸŸ¢ **DigiftAdapterFactory** | 100% | âœ… Pass | 1 | [View](#digiftadapterfactory) |
| ğŸŸ  **DigiftEventVerifier** | 30% | âŒ Fail | 4 | [View](#digifteventverifier) |



## ğŸ” Detailed Contract Analysis

### Escrow

**Coverage:** 0%
`â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘`

## ğŸ“ˆ Coverage Statistics

| Metric | Value |
|--------|-------|
| Total Functions | 0 |
| Line Coverage | 0% |

<details>
<summary>ğŸ“Š Full Coverage Report</summary>

```
ğŸ“„ File: src/Escrow.sol
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ (index)                    â”‚ Values â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ totalFunctions             â”‚ 0      â”‚
â”‚ fullyCoveredFunctions      â”‚ 0      â”‚
â”‚ coveredLines               â”‚ 0      â”‚
â”‚ revertedLines              â”‚ 0      â”‚
â”‚ untouchedLines             â”‚ 0      â”‚
â”‚ functionCoveragePercentage â”‚ 0      â”‚
â”‚ lineCoveragePercentage     â”‚ 0      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”˜

âŒ Warning: Coverage 0% below threshold 70%
```

</details>

### Node

**Coverage:** 65.06%
`â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘`

## ğŸ“ˆ Coverage Statistics

| Metric | Value |
|--------|-------|
| Total Functions | 45 |
| Line Coverage | 65.06% |

## âš ï¸ Uncovered Functions

| Index | Function Name | Touched | Reverted | Untouched Lines |
|-------|---------------|---------|----------|----------------|
| 0 | `addPolicies` | false | false | 1 |
| 1 | `removePolicies` | false | false | 1 |
| 2 | `removeComponent` | false | false | 7 |
| 3 | `removeRouter` | false | false | 3 |
| 4 | `addRebalancer` | true | false | 1 |
| 5 | `removeRebalancer` | false | false | 3 |
| 6 | `setNodeOwnerFeeAddress` | false | false | 4 |
| 7 | `rescueTokens` | false | false | 4 |
| 8 | `execute` | false | false | 5 |
| 9 | `_payManagementFees` | true | false | 1 |
| 10 | `subtractProtocolExecutionFee` | true | false | 4 |
| 11 | `updateTotalAssets` | false | false | 2 |
| 12 | `fulfillRedeemFromReserve` | false | false | 2 |
| 13 | `finalizeRedemption` | false | false | 2 |
| 14 | `deposit` | true | false | 2 |
| 15 | `mint` | true | false | 3 |
| 16 | `withdraw` | true | false | 12 |
| 17 | `redeem` | true | false | 12 |
| 18 | `transfer` | true | false | 1 |
| 19 | `_fulfillRedeemFromReserve` | false | false | 10 |
| 20 | `_finalizeRedemption` | false | false | 11 |
| 21 | `_validateOwner` | true | false | 2 |
| 22 | `_runPolicies` | true | false | 1 |

## ğŸ” Uncovered Code Lines

### Function: `addPolicies`

```solidity
âŒ Untouched lines:
```

```solidity
NodeLib.addPolicies(registry, policies, sigPolicy, proof, proofFlags, sigs, policies_);
```

### Function: `removePolicies`

```solidity
âŒ Untouched lines:
```

```solidity
NodeLib.removePolicies(policies, sigPolicy, sigs, policies_);
```

### Function: `removeComponent`

```solidity
âŒ Untouched lines:
```

```solidity
if (!_isComponent(component)) revert ErrorsLib.NotSet();
```

```solidity
address router = componentAllocations[component].router;
```

```solidity
revert ErrorsLib.NonZeroBalance();
```

```solidity
revert ErrorsLib.NotBlacklisted();
```

```solidity
NodeLib.remove(components, component);
```

```solidity
delete componentAllocations[component];
```

```solidity
emit EventsLib.ComponentRemoved(component);
```

### Function: `removeRouter`

```solidity
âŒ Untouched lines:
```

```solidity
if (!isRouter[oldRouter]) revert ErrorsLib.NotSet();
```

```solidity
isRouter[oldRouter] = false;
```

```solidity
emit EventsLib.RouterRemoved(oldRouter);
```

### Function: `addRebalancer`

```solidity
âŒ Untouched lines:
```

```solidity
revert ErrorsLib.NotWhitelisted();
```

### Function: `removeRebalancer`

```solidity
âŒ Untouched lines:
```

```solidity
if (!isRebalancer[oldRebalancer]) revert ErrorsLib.NotSet();
```

```solidity
isRebalancer[oldRebalancer] = false;
```

```solidity
emit EventsLib.RebalancerRemoved(oldRebalancer);
```

### Function: `setNodeOwnerFeeAddress`

```solidity
âŒ Untouched lines:
```

```solidity
_nonZeroAddress(newNodeOwnerFeeAddress);
```

```solidity
if (newNodeOwnerFeeAddress == nodeOwnerFeeAddress) revert ErrorsLib.AlreadySet();
```

```solidity
nodeOwnerFeeAddress = newNodeOwnerFeeAddress;
```

```solidity
emit EventsLib.NodeOwnerFeeAddressSet(newNodeOwnerFeeAddress);
```

### Function: `rescueTokens`

```solidity
âŒ Untouched lines:
```

```solidity
if (token == asset) revert ErrorsLib.InvalidToken();
```

```solidity
if (_isComponent(token)) revert ErrorsLib.InvalidToken();
```

```solidity
IERC20(token).safeTransfer(recipient, amount);
```

```solidity
emit EventsLib.RescueTokens(token, recipient, amount);
```

### Function: `execute`

```solidity
âŒ Untouched lines:
```

```solidity
_nonZeroAddress(target);
```

```solidity
bytes memory result = target.functionCall(data);
```

```solidity
_runPolicies();
```

```solidity
emit EventsLib.Execute(target, data, result);
```

```solidity
return result;
```

### Function: `_payManagementFees`

```solidity
âŒ Untouched lines:
```

```solidity
revert ErrorsLib.NotEnoughAssetsToPayFees(feeForPeriod, IERC20(asset).balanceOf(address(this)));
```

### Function: `subtractProtocolExecutionFee`

```solidity
âŒ Untouched lines:
```

```solidity
cacheTotalAssets -= executionFee;
```

```solidity
IERC20(asset).safeTransfer(INodeRegistry(registry).protocolFeeAddress(), executionFee);
```

```solidity
_runPolicies();
```

```solidity
emit EventsLib.ExecutionFeeTaken(executionFee);
```

### Function: `updateTotalAssets`

```solidity
âŒ Untouched lines:
```

```solidity
_updateTotalAssets();
```

```solidity
_runPolicies();
```

### Function: `fulfillRedeemFromReserve`

```solidity
âŒ Untouched lines:
```

```solidity
_fulfillRedeemFromReserve(controller);
```

```solidity
_runPolicies();
```

### Function: `finalizeRedemption`

```solidity
âŒ Untouched lines:
```

```solidity
_finalizeRedemption(controller, assetsToReturn, sharesPending, sharesAdjusted);
```

```solidity
_runPolicies();
```

### Function: `deposit`

```solidity
âŒ Untouched lines:
```

```solidity
revert ErrorsLib.ExceedsMaxDeposit();
```

```solidity
return shares;
```

### Function: `mint`

```solidity
âŒ Untouched lines:
```

```solidity
revert ErrorsLib.ExceedsMaxMint();
```

```solidity
_runPolicies();
```

```solidity
return assets;
```

### Function: `withdraw`

```solidity
âŒ Untouched lines:
```

```solidity
_validateController(controller);
```

```solidity
Request storage request = requests[controller];
```

```solidity
uint256 maxAssets = maxWithdraw(controller);
```

```solidity
uint256 maxShares = maxRedeem(controller);
```

```solidity
if (assets > maxAssets) revert ErrorsLib.ExceedsMaxWithdraw();
```

```solidity
shares = Math.mulDiv(assets, maxShares, maxAssets, Math.Rounding.Ceil);
```

```solidity
request.claimableRedeemRequest -= shares;
```

```solidity
request.claimableAssets -= assets;
```

```solidity
IERC20(asset).safeTransferFrom(escrow, receiver, assets);
```

```solidity
_runPolicies();
```

```solidity
emit IERC7575.Withdraw(msg.sender, receiver, controller, assets, shares);
```

```solidity
return shares;
```

### Function: `redeem`

```solidity
âŒ Untouched lines:
```

```solidity
_validateController(controller);
```

```solidity
Request storage request = requests[controller];
```

```solidity
uint256 maxAssets = maxWithdraw(controller);
```

```solidity
uint256 maxShares = maxRedeem(controller);
```

```solidity
if (shares > maxShares) revert ErrorsLib.ExceedsMaxRedeem();
```

```solidity
assets = Math.mulDiv(shares, maxAssets, maxShares);
```

```solidity
request.claimableRedeemRequest -= shares;
```

```solidity
request.claimableAssets -= assets;
```

```solidity
IERC20(asset).safeTransferFrom(escrow, receiver, assets);
```

```solidity
_runPolicies();
```

```solidity
emit IERC7575.Withdraw(msg.sender, receiver, controller, assets, shares);
```

```solidity
return assets;
```

### Function: `transfer`

```solidity
âŒ Untouched lines:
```

```solidity
_runPolicies();
```

### Function: `_fulfillRedeemFromReserve`

```solidity
âŒ Untouched lines:
```

```solidity
Request storage request = requests[controller];
```

```solidity
if (request.pendingRedeemRequest == 0) revert ErrorsLib.NoPendingRedeemRequest();
```

```solidity
uint256 balance = Math.max(IERC20(asset).balanceOf(address(this)), 1);
```

```solidity
uint256 assetsToReturn = convertToAssets(request.sharesAdjusted);
```

```solidity
uint256 sharesPending = request.pendingRedeemRequest;
```

```solidity
uint256 sharesAdjusted = request.sharesAdjusted;
```

```solidity
sharesPending = (sharesPending * balance - 1) / assetsToReturn + 1;
```

```solidity
sharesAdjusted = (sharesAdjusted * balance - 1) / assetsToReturn + 1;
```

```solidity
assetsToReturn = balance;
```

```solidity
_finalizeRedemption(controller, assetsToReturn, sharesPending, sharesAdjusted);
```

### Function: `_finalizeRedemption`

```solidity
âŒ Untouched lines:
```

```solidity
Request storage request = requests[controller];
```

```solidity
_burn(escrow, sharesPending);
```

```solidity
request.pendingRedeemRequest -= sharesPending;
```

```solidity
request.claimableRedeemRequest += sharesPending;
```

```solidity
request.claimableAssets += assetsToReturn;
```

```solidity
request.sharesAdjusted -= sharesAdjusted;
```

```solidity
sharesExiting -= sharesAdjusted;
```

```solidity
cacheTotalAssets -= assetsToReturn;
```

```solidity
revert ErrorsLib.ExceedsAvailableReserve();
```

```solidity
IERC20(asset).safeTransfer(escrow, assetsToReturn);
```

```solidity
emit EventsLib.RedeemClaimable(controller, REQUEST_ID, assetsToReturn, sharesPending);
```

### Function: `_validateOwner`

```solidity
âŒ Untouched lines:
```

```solidity
revert ErrorsLib.InvalidOwner();
```

```solidity
_spendAllowance(owner, msg.sender, shares);
```

### Function: `_runPolicies`

```solidity
âŒ Untouched lines:
```

```solidity
IPolicy(policies_[i]).onCheck(msg.sender, msg.data);
```

```solidity
âŒ Warning: Coverage 65.06% below threshold 70%
```


<details>
<summary>ğŸ“Š Full Coverage Report</summary>

```
ğŸ“„ File: src/Node.sol
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ (index)                    â”‚ Values â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ totalFunctions             â”‚ 45     â”‚
â”‚ fullyCoveredFunctions      â”‚ 22     â”‚
â”‚ coveredLines               â”‚ 175    â”‚
â”‚ revertedLines              â”‚ 0      â”‚
â”‚ untouchedLines             â”‚ 94     â”‚
â”‚ functionCoveragePercentage â”‚ 48.89  â”‚
â”‚ lineCoveragePercentage     â”‚ 65.06  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”˜

âš ï¸ Not fully covered functions:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ (index) â”‚ functionName                   â”‚ touched â”‚ reverted â”‚ untouchedLines â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 0       â”‚ 'addPolicies'                  â”‚ false   â”‚ false    â”‚ 1              â”‚
â”‚ 1       â”‚ 'removePolicies'               â”‚ false   â”‚ false    â”‚ 1              â”‚
â”‚ 2       â”‚ 'removeComponent'              â”‚ false   â”‚ false    â”‚ 7              â”‚
â”‚ 3       â”‚ 'removeRouter'                 â”‚ false   â”‚ false    â”‚ 3              â”‚
â”‚ 4       â”‚ 'addRebalancer'                â”‚ true    â”‚ false    â”‚ 1              â”‚
â”‚ 5       â”‚ 'removeRebalancer'             â”‚ false   â”‚ false    â”‚ 3              â”‚
â”‚ 6       â”‚ 'setNodeOwnerFeeAddress'       â”‚ false   â”‚ false    â”‚ 4              â”‚
â”‚ 7       â”‚ 'rescueTokens'                 â”‚ false   â”‚ false    â”‚ 4              â”‚
â”‚ 8       â”‚ 'execute'                      â”‚ false   â”‚ false    â”‚ 5              â”‚
â”‚ 9       â”‚ '_payManagementFees'           â”‚ true    â”‚ false    â”‚ 1              â”‚
â”‚ 10      â”‚ 'subtractProtocolExecutionFee' â”‚ true    â”‚ false    â”‚ 4              â”‚
â”‚ 11      â”‚ 'updateTotalAssets'            â”‚ false   â”‚ false    â”‚ 2              â”‚
â”‚ 12      â”‚ 'fulfillRedeemFromReserve'     â”‚ false   â”‚ false    â”‚ 2              â”‚
â”‚ 13      â”‚ 'finalizeRedemption'           â”‚ false   â”‚ false    â”‚ 2              â”‚
â”‚ 14      â”‚ 'deposit'                      â”‚ true    â”‚ false    â”‚ 2              â”‚
â”‚ 15      â”‚ 'mint'                         â”‚ true    â”‚ false    â”‚ 3              â”‚
â”‚ 16      â”‚ 'withdraw'                     â”‚ true    â”‚ false    â”‚ 12             â”‚
â”‚ 17      â”‚ 'redeem'                       â”‚ true    â”‚ false    â”‚ 12             â”‚
â”‚ 18      â”‚ 'transfer'                     â”‚ true    â”‚ false    â”‚ 1              â”‚
â”‚ 19      â”‚ '_fulfillRedeemFromReserve'    â”‚ false   â”‚ false    â”‚ 10             â”‚
â”‚ 20      â”‚ '_finalizeRedemption'          â”‚ false   â”‚ false    â”‚ 11             â”‚
â”‚ 21      â”‚ '_validateOwner'               â”‚ true    â”‚ false    â”‚ 2              â”‚
â”‚ 22      â”‚ '_runPolicies'                 â”‚ true    â”‚ false    â”‚ 1              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Function: addPolicies
âŒ Untouched lines:
NodeLib.addPolicies(registry, policies, sigPolicy, proof, proofFlags, sigs, policies_);

Function: removePolicies
âŒ Untouched lines:
NodeLib.removePolicies(policies, sigPolicy, sigs, policies_);

Function: removeComponent
âŒ Untouched lines:
if (!_isComponent(component)) revert ErrorsLib.NotSet();
address router = componentAllocations[component].router;
revert ErrorsLib.NonZeroBalance();
revert ErrorsLib.NotBlacklisted();
NodeLib.remove(components, component);
delete componentAllocations[component];
emit EventsLib.ComponentRemoved(component);

Function: removeRouter
âŒ Untouched lines:
if (!isRouter[oldRouter]) revert ErrorsLib.NotSet();
isRouter[oldRouter] = false;
emit EventsLib.RouterRemoved(oldRouter);

Function: addRebalancer
âŒ Untouched lines:
revert ErrorsLib.NotWhitelisted();

Function: removeRebalancer
âŒ Untouched lines:
if (!isRebalancer[oldRebalancer]) revert ErrorsLib.NotSet();
isRebalancer[oldRebalancer] = false;
emit EventsLib.RebalancerRemoved(oldRebalancer);

Function: setNodeOwnerFeeAddress
âŒ Untouched lines:
_nonZeroAddress(newNodeOwnerFeeAddress);
if (newNodeOwnerFeeAddress == nodeOwnerFeeAddress) revert ErrorsLib.AlreadySet();
nodeOwnerFeeAddress = newNodeOwnerFeeAddress;
emit EventsLib.NodeOwnerFeeAddressSet(newNodeOwnerFeeAddress);

Function: rescueTokens
âŒ Untouched lines:
if (token == asset) revert ErrorsLib.InvalidToken();
if (_isComponent(token)) revert ErrorsLib.InvalidToken();
IERC20(token).safeTransfer(recipient, amount);
emit EventsLib.RescueTokens(token, recipient, amount);

Function: execute
âŒ Untouched lines:
_nonZeroAddress(target);
bytes memory result = target.functionCall(data);
_runPolicies();
emit EventsLib.Execute(target, data, result);
return result;

Function: _payManagementFees
âŒ Untouched lines:
revert ErrorsLib.NotEnoughAssetsToPayFees(feeForPeriod, IERC20(asset).balanceOf(address(this)));

Function: subtractProtocolExecutionFee
âŒ Untouched lines:
cacheTotalAssets -= executionFee;
IERC20(asset).safeTransfer(INodeRegistry(registry).protocolFeeAddress(), executionFee);
_runPolicies();
emit EventsLib.ExecutionFeeTaken(executionFee);

Function: updateTotalAssets
âŒ Untouched lines:
_updateTotalAssets();
_runPolicies();

Function: fulfillRedeemFromReserve
âŒ Untouched lines:
_fulfillRedeemFromReserve(controller);
_runPolicies();

Function: finalizeRedemption
âŒ Untouched lines:
_finalizeRedemption(controller, assetsToReturn, sharesPending, sharesAdjusted);
_runPolicies();

Function: deposit
âŒ Untouched lines:
revert ErrorsLib.ExceedsMaxDeposit();
return shares;

Function: mint
âŒ Untouched lines:
revert ErrorsLib.ExceedsMaxMint();
_runPolicies();
return assets;

Function: withdraw
âŒ Untouched lines:
_validateController(controller);
Request storage request = requests[controller];
uint256 maxAssets = maxWithdraw(controller);
uint256 maxShares = maxRedeem(controller);
if (assets > maxAssets) revert ErrorsLib.ExceedsMaxWithdraw();
shares = Math.mulDiv(assets, maxShares, maxAssets, Math.Rounding.Ceil);
request.claimableRedeemRequest -= shares;
request.claimableAssets -= assets;
IERC20(asset).safeTransferFrom(escrow, receiver, assets);
_runPolicies();
emit IERC7575.Withdraw(msg.sender, receiver, controller, assets, shares);
return shares;

Function: redeem
âŒ Untouched lines:
_validateController(controller);
Request storage request = requests[controller];
uint256 maxAssets = maxWithdraw(controller);
uint256 maxShares = maxRedeem(controller);
if (shares > maxShares) revert ErrorsLib.ExceedsMaxRedeem();
assets = Math.mulDiv(shares, maxAssets, maxShares);
request.claimableRedeemRequest -= shares;
request.claimableAssets -= assets;
IERC20(asset).safeTransferFrom(escrow, receiver, assets);
_runPolicies();
emit IERC7575.Withdraw(msg.sender, receiver, controller, assets, shares);
return assets;

Function: transfer
âŒ Untouched lines:
_runPolicies();

Function: _fulfillRedeemFromReserve
âŒ Untouched lines:
Request storage request = requests[controller];
if (request.pendingRedeemRequest == 0) revert ErrorsLib.NoPendingRedeemRequest();
uint256 balance = Math.max(IERC20(asset).balanceOf(address(this)), 1);
uint256 assetsToReturn = convertToAssets(request.sharesAdjusted);
uint256 sharesPending = request.pendingRedeemRequest;
uint256 sharesAdjusted = request.sharesAdjusted;
sharesPending = (sharesPending * balance - 1) / assetsToReturn + 1;
sharesAdjusted = (sharesAdjusted * balance - 1) / assetsToReturn + 1;
assetsToReturn = balance;
_finalizeRedemption(controller, assetsToReturn, sharesPending, sharesAdjusted);

Function: _finalizeRedemption
âŒ Untouched lines:
Request storage request = requests[controller];
_burn(escrow, sharesPending);
request.pendingRedeemRequest -= sharesPending;
request.claimableRedeemRequest += sharesPending;
request.claimableAssets += assetsToReturn;
request.sharesAdjusted -= sharesAdjusted;
sharesExiting -= sharesAdjusted;
cacheTotalAssets -= assetsToReturn;
revert ErrorsLib.ExceedsAvailableReserve();
IERC20(asset).safeTransfer(escrow, assetsToReturn);
emit EventsLib.RedeemClaimable(controller, REQUEST_ID, assetsToReturn, sharesPending);

Function: _validateOwner
âŒ Untouched lines:
revert ErrorsLib.InvalidOwner();
_spendAllowance(owner, msg.sender, shares);

Function: _runPolicies
âŒ Untouched lines:
IPolicy(policies_[i]).onCheck(msg.sender, msg.data);

âŒ Warning: Coverage 65.06% below threshold 70%
```

</details>

### NodeFactory

**Coverage:** 75%
`â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘`

## ğŸ“ˆ Coverage Statistics

| Metric | Value |
|--------|-------|
| Total Functions | 1 |
| Line Coverage | 75% |

## âš ï¸ Uncovered Functions

| Index | Function Name | Touched | Reverted | Untouched Lines |
|-------|---------------|---------|----------|----------------|
| 0 | `invest` | false | false | 12 |
| 1 | `liquidate` | false | false | 4 |
| 2 | `fulfillRedeemRequest` | false | false | 12 |
| 3 | `_deposit` | false | false | 4 |
| 4 | `_redeem` | false | false | 2 |
| 5 | `_liquidate` | false | false | 2 |

## ğŸ” Uncovered Code Lines

```solidity
ğŸ“„ File: routers/ERC4626Router.sol
```

```solidity
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”
```

```solidity
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¤
```

```solidity
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

```solidity
âš ï¸ Not fully covered functions:
```

```solidity
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
```

```solidity
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
```

```solidity
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Function: `invest`

```solidity
âŒ Untouched lines:
```

```solidity
depositAmount = _computeDepositAmount(node, component);
```

```solidity
revert ExceedsMaxComponentDeposit(component, depositAmount, IERC4626(component).maxDeposit(address(node)));
```

```solidity
uint256 sharesBefore = IERC4626(component).balanceOf(address(node));
```

```solidity
uint256 sharesReturned;
```

```solidity
_deposit(node, component, depositAmount);
```

```solidity
uint256 sharesAfter = IERC4626(component).balanceOf(address(node));
```

```solidity
revert InsufficientSharesReturned(component, 0, expectedShares);
```

```solidity
sharesReturned = sharesAfter - sharesBefore;
```

```solidity
revert InsufficientSharesReturned(component, sharesReturned, expectedShares);
```

```solidity
revert InsufficientSharesReturned(component, sharesReturned, minSharesOut);
```

```solidity
emit InvestedInComponent(node, component, depositAmount);
```

```solidity
return depositAmount;
```

### Function: `liquidate`

```solidity
âŒ Untouched lines:
```

```solidity
assetsReturned = _liquidate(node, component, shares);
```

```solidity
revert InsufficientAssetsReturned(component, assetsReturned, minAssetsOut);
```

```solidity
emit LiquidatedFromComponent(node, component, assetsReturned);
```

```solidity
return assetsReturned;
```

### Function: `fulfillRedeemRequest`

```solidity
âŒ Untouched lines:
```

```solidity
(uint256 sharesPending,,, uint256 sharesAdjusted) = INode(node).requests(controller);
```

```solidity
uint256 assetsRequested = INode(node).convertToAssets(sharesAdjusted);
```

```solidity
INode(node).enforceLiquidationOrder(component, assetsRequested);
```

```solidity
uint256 componentShares =
```

```solidity
Math.min(IERC4626(component).convertToShares(assetsRequested), IERC20(component).balanceOf(address(node)));
```

```solidity
assetsReturned = _liquidate(node, component, componentShares);
```

```solidity
revert InsufficientAssetsReturned(component, assetsReturned, minAssetsOut);
```

```solidity
(sharesPending, sharesAdjusted) =
```

```solidity
_calculatePartialFulfill(sharesPending, assetsReturned, assetsRequested, sharesAdjusted);
```

```solidity
INode(node).finalizeRedemption(controller, assetsReturned, sharesPending, sharesAdjusted);
```

```solidity
emit FulfilledRedeemRequest(node, component, assetsReturned);
```

```solidity
return assetsReturned;
```

### Function: `_deposit`

```solidity
âŒ Untouched lines:
```

```solidity
address underlying = INode(node).asset();
```

```solidity
_safeApprove(node, underlying, component, assets);
```

```solidity
bytes memory result = INode(node).execute(component, abi.encodeCall(IERC4626.deposit, (assets, node)));
```

```solidity
return abi.decode(result, (uint256));
```

### Function: `_redeem`

```solidity
âŒ Untouched lines:
```

```solidity
bytes memory result = INode(node).execute(component, abi.encodeCall(IERC4626.redeem, (shares, node, node)));
```

```solidity
return abi.decode(result, (uint256));
```

### Function: `_liquidate`

```solidity
âŒ Untouched lines:
```

```solidity
if (shares == 0
```

```solidity
revert InvalidShareValue(component, shares);
```

```solidity
âŒ Warning: Coverage 14.29% below threshold 70%
```


<details>
<summary>ğŸ“Š Full Coverage Report</summary>

```
ğŸ“„ File: routers/ERC4626Router.sol
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ (index)                    â”‚ Values â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ totalFunctions             â”‚ 6      â”‚
â”‚ fullyCoveredFunctions      â”‚ 0      â”‚
â”‚ coveredLines               â”‚ 6      â”‚
â”‚ revertedLines              â”‚ 0      â”‚
â”‚ untouchedLines             â”‚ 36     â”‚
â”‚ functionCoveragePercentage â”‚ 0      â”‚
â”‚ lineCoveragePercentage     â”‚ 14.29  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”˜

âš ï¸ Not fully covered functions:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ (index) â”‚ functionName           â”‚ touched â”‚ reverted â”‚ untouchedLines â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 0       â”‚ 'invest'               â”‚ false   â”‚ false    â”‚ 12             â”‚
â”‚ 1       â”‚ 'liquidate'            â”‚ false   â”‚ false    â”‚ 4              â”‚
â”‚ 2       â”‚ 'fulfillRedeemRequest' â”‚ false   â”‚ false    â”‚ 12             â”‚
â”‚ 3       â”‚ '_deposit'             â”‚ false   â”‚ false    â”‚ 4              â”‚
â”‚ 4       â”‚ '_redeem'              â”‚ false   â”‚ false    â”‚ 2              â”‚
â”‚ 5       â”‚ '_liquidate'           â”‚ false   â”‚ false    â”‚ 2              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Function: invest
âŒ Untouched lines:
depositAmount = _computeDepositAmount(node, component);
revert ExceedsMaxComponentDeposit(component, depositAmount, IERC4626(component).maxDeposit(address(node)));
uint256 sharesBefore = IERC4626(component).balanceOf(address(node));
uint256 sharesReturned;
_deposit(node, component, depositAmount);
uint256 sharesAfter = IERC4626(component).balanceOf(address(node));
revert InsufficientSharesReturned(component, 0, expectedShares);
sharesReturned = sharesAfter - sharesBefore;
revert InsufficientSharesReturned(component, sharesReturned, expectedShares);
revert InsufficientSharesReturned(component, sharesReturned, minSharesOut);
emit InvestedInComponent(node, component, depositAmount);
return depositAmount;

Function: liquidate
âŒ Untouched lines:
assetsReturned = _liquidate(node, component, shares);
revert InsufficientAssetsReturned(component, assetsReturned, minAssetsOut);
emit LiquidatedFromComponent(node, component, assetsReturned);
return assetsReturned;

Function: fulfillRedeemRequest
âŒ Untouched lines:
(uint256 sharesPending,,, uint256 sharesAdjusted) = INode(node).requests(controller);
uint256 assetsRequested = INode(node).convertToAssets(sharesAdjusted);
INode(node).enforceLiquidationOrder(component, assetsRequested);
uint256 componentShares =
Math.min(IERC4626(component).convertToShares(assetsRequested), IERC20(component).balanceOf(address(node)));
assetsReturned = _liquidate(node, component, componentShares);
revert InsufficientAssetsReturned(component, assetsReturned, minAssetsOut);
(sharesPending, sharesAdjusted) =
_calculatePartialFulfill(sharesPending, assetsReturned, assetsRequested, sharesAdjusted);
INode(node).finalizeRedemption(controller, assetsReturned, sharesPending, sharesAdjusted);
emit FulfilledRedeemRequest(node, component, assetsReturned);
return assetsReturned;

Function: _deposit
âŒ Untouched lines:
address underlying = INode(node).asset();
_safeApprove(node, underlying, component, assets);
bytes memory result = INode(node).execute(component, abi.encodeCall(IERC4626.deposit, (assets, node)));
return abi.decode(result, (uint256));

Function: _redeem
âŒ Untouched lines:
bytes memory result = INode(node).execute(component, abi.encodeCall(IERC4626.redeem, (shares, node, node)));
return abi.decode(result, (uint256));

Function: _liquidate
âŒ Untouched lines:
if (shares == 0
revert InvalidShareValue(component, shares);

âŒ Warning: Coverage 14.29% below threshold 70%
```

</details>

### NodeRegistry

**Coverage:** 93.48%
`â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘`

## ğŸ“ˆ Coverage Statistics

| Metric | Value |
|--------|-------|
| Total Functions | 13 |
| Line Coverage | 93.48% |

## âš ï¸ Uncovered Functions

| Index | Function Name | Touched | Reverted | Untouched Lines |
|-------|---------------|---------|----------|----------------|
| 0 | `fulfillRedeemRequest` | false | false | 11 |
| 1 | `investInAsyncComponent` | false | false | 5 |
| 2 | `mintClaimableShares` | false | false | 10 |
| 3 | `requestAsyncWithdrawal` | false | false | 5 |
| 4 | `executeAsyncWithdrawal` | false | false | 1 |
| 5 | `_requestDeposit` | false | false | 5 |
| 6 | `_mint` | true | false | 2 |
| 7 | `_requestRedeem` | false | false | 5 |
| 8 | `_withdraw` | false | false | 2 |
| 9 | `_executeAsyncWithdrawal` | false | false | 10 |

## ğŸ” Uncovered Code Lines

### Function: `fulfillRedeemRequest`

```solidity
âŒ Untouched lines:
```

```solidity
(uint256 sharesPending,,, uint256 sharesAdjusted) = INode(node).requests(controller);
```

```solidity
uint256 assetsRequested = INode(node).convertToAssets(sharesAdjusted);
```

```solidity
INode(node).enforceLiquidationOrder(component, assetsRequested);
```

```solidity
uint256 maxClaimableRedeemRequest = IERC7540Redeem(component).claimableRedeemRequest(0, node);
```

```solidity
uint256 maxClaimableAssets = IERC7575(component).convertToAssets(maxClaimableRedeemRequest);
```

```solidity
assetsReturned = _executeAsyncWithdrawal(node, component, Math.min(assetsRequested, maxClaimableAssets));
```

```solidity
(sharesPending, sharesAdjusted) =
```

```solidity
_calculatePartialFulfill(sharesPending, assetsReturned, assetsRequested, sharesAdjusted);
```

```solidity
INode(node).finalizeRedemption(controller, assetsReturned, sharesPending, sharesAdjusted);
```

```solidity
emit FulfilledRedeemRequest(node, component, assetsReturned);
```

```solidity
return assetsReturned;
```

### Function: `investInAsyncComponent`

```solidity
âŒ Untouched lines:
```

```solidity
depositAmount = _computeDepositAmount(node, component);
```

```solidity
uint256 requestId = _requestDeposit(node, component, depositAmount);
```

```solidity
revert IncorrectRequestId(requestId);
```

```solidity
emit InvestedInAsyncComponent(node, component, depositAmount);
```

```solidity
return depositAmount;
```

### Function: `mintClaimableShares`

```solidity
âŒ Untouched lines:
```

```solidity
uint256 claimableShares = IERC7575(component).maxMint(address(node));
```

```solidity
address share = IERC7575(component).share();
```

```solidity
uint256 balanceBefore = IERC20(share).balanceOf(address(node));
```

```solidity
_mint(node, component, claimableShares);
```

```solidity
uint256 balanceAfter = IERC20(share).balanceOf(address(node));
```

```solidity
revert InsufficientSharesReturned(component, 0, claimableShares);
```

```solidity
sharesReceived = balanceAfter - balanceBefore;
```

```solidity
revert InsufficientSharesReturned(component, sharesReceived, claimableShares);
```

```solidity
emit MintedClaimableShares(node, component, sharesReceived);
```

```solidity
return sharesReceived;
```

### Function: `requestAsyncWithdrawal`

```solidity
âŒ Untouched lines:
```

```solidity
address shareToken = IERC7575(component).share();
```

```solidity
revert ExceedsAvailableShares(node, component, shares);
```

```solidity
uint256 requestId = _requestRedeem(node, component, shares);
```

```solidity
revert IncorrectRequestId(requestId);
```

```solidity
emit RequestedAsyncWithdrawal(node, component, shares);
```

### Function: `executeAsyncWithdrawal`

```solidity
âŒ Untouched lines:
```

```solidity
assetsReceived = _executeAsyncWithdrawal(node, component, assets);
```

### Function: `_requestDeposit`

```solidity
âŒ Untouched lines:
```

```solidity
address underlying = INode(node).asset();
```

```solidity
_safeApprove(node, underlying, component, assets);
```

```solidity
bytes memory result =
```

```solidity
INode(node).execute(component, abi.encodeCall(IERC7540Deposit.requestDeposit, (assets, node, node)));
```

```solidity
return abi.decode(result, (uint256));
```

### Function: `_mint`

```solidity
âŒ Untouched lines:
```

```solidity
bytes memory result =
```

```solidity
INode(node).execute(component, abi.encodeCall(IERC7540Deposit.mint, (claimableShares, node, node)));
```

### Function: `_requestRedeem`

```solidity
âŒ Untouched lines:
```

```solidity
address shareToken = IERC7575(component).share();
```

```solidity
_safeApprove(node, shareToken, component, shares);
```

```solidity
bytes memory result =
```

```solidity
INode(node).execute(component, abi.encodeCall(IERC7540Redeem.requestRedeem, (shares, node, node)));
```

```solidity
return abi.decode(result, (uint256));
```

### Function: `_withdraw`

```solidity
âŒ Untouched lines:
```

```solidity
bytes memory result = INode(node).execute(component, abi.encodeCall(IERC7575.withdraw, (assets, node, node)));
```

```solidity
return abi.decode(result, (uint256));
```

### Function: `_executeAsyncWithdrawal`

```solidity
âŒ Untouched lines:
```

```solidity
revert ExceedsAvailableAssets(node, component, assets);
```

```solidity
address asset = IERC7575(node).asset();
```

```solidity
uint256 balanceBefore = IERC20(asset).balanceOf(address(node));
```

```solidity
_withdraw(node, component, assets);
```

```solidity
uint256 balanceAfter = IERC20(asset).balanceOf(address(node));
```

```solidity
revert InsufficientAssetsReturned(component, 0, assets);
```

```solidity
assetsReceived = balanceAfter - balanceBefore;
```

```solidity
revert InsufficientAssetsReturned(component, assetsReceived, assets);
```

```solidity
emit AsyncWithdrawalExecuted(node, component, assetsReceived);
```

```solidity
return assetsReceived;
```

```solidity
âŒ Warning: Coverage 16.42% below threshold 70%
```


<details>
<summary>ğŸ“Š Full Coverage Report</summary>

```
ğŸ“„ File: routers/ERC7540Router.sol
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ (index)                    â”‚ Values â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ totalFunctions             â”‚ 10     â”‚
â”‚ fullyCoveredFunctions      â”‚ 0      â”‚
â”‚ coveredLines               â”‚ 11     â”‚
â”‚ revertedLines              â”‚ 0      â”‚
â”‚ untouchedLines             â”‚ 56     â”‚
â”‚ functionCoveragePercentage â”‚ 0      â”‚
â”‚ lineCoveragePercentage     â”‚ 16.42  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”˜

âš ï¸ Not fully covered functions:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ (index) â”‚ functionName              â”‚ touched â”‚ reverted â”‚ untouchedLines â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 0       â”‚ 'fulfillRedeemRequest'    â”‚ false   â”‚ false    â”‚ 11             â”‚
â”‚ 1       â”‚ 'investInAsyncComponent'  â”‚ false   â”‚ false    â”‚ 5              â”‚
â”‚ 2       â”‚ 'mintClaimableShares'     â”‚ false   â”‚ false    â”‚ 10             â”‚
â”‚ 3       â”‚ 'requestAsyncWithdrawal'  â”‚ false   â”‚ false    â”‚ 5              â”‚
â”‚ 4       â”‚ 'executeAsyncWithdrawal'  â”‚ false   â”‚ false    â”‚ 1              â”‚
â”‚ 5       â”‚ '_requestDeposit'         â”‚ false   â”‚ false    â”‚ 5              â”‚
â”‚ 6       â”‚ '_mint'                   â”‚ true    â”‚ false    â”‚ 2              â”‚
â”‚ 7       â”‚ '_requestRedeem'          â”‚ false   â”‚ false    â”‚ 5              â”‚
â”‚ 8       â”‚ '_withdraw'               â”‚ false   â”‚ false    â”‚ 2              â”‚
â”‚ 9       â”‚ '_executeAsyncWithdrawal' â”‚ false   â”‚ false    â”‚ 10             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Function: fulfillRedeemRequest
âŒ Untouched lines:
(uint256 sharesPending,,, uint256 sharesAdjusted) = INode(node).requests(controller);
uint256 assetsRequested = INode(node).convertToAssets(sharesAdjusted);
INode(node).enforceLiquidationOrder(component, assetsRequested);
uint256 maxClaimableRedeemRequest = IERC7540Redeem(component).claimableRedeemRequest(0, node);
uint256 maxClaimableAssets = IERC7575(component).convertToAssets(maxClaimableRedeemRequest);
assetsReturned = _executeAsyncWithdrawal(node, component, Math.min(assetsRequested, maxClaimableAssets));
(sharesPending, sharesAdjusted) =
_calculatePartialFulfill(sharesPending, assetsReturned, assetsRequested, sharesAdjusted);
INode(node).finalizeRedemption(controller, assetsReturned, sharesPending, sharesAdjusted);
emit FulfilledRedeemRequest(node, component, assetsReturned);
return assetsReturned;

Function: investInAsyncComponent
âŒ Untouched lines:
depositAmount = _computeDepositAmount(node, component);
uint256 requestId = _requestDeposit(node, component, depositAmount);
revert IncorrectRequestId(requestId);
emit InvestedInAsyncComponent(node, component, depositAmount);
return depositAmount;

Function: mintClaimableShares
âŒ Untouched lines:
uint256 claimableShares = IERC7575(component).maxMint(address(node));
address share = IERC7575(component).share();
uint256 balanceBefore = IERC20(share).balanceOf(address(node));
_mint(node, component, claimableShares);
uint256 balanceAfter = IERC20(share).balanceOf(address(node));
revert InsufficientSharesReturned(component, 0, claimableShares);
sharesReceived = balanceAfter - balanceBefore;
revert InsufficientSharesReturned(component, sharesReceived, claimableShares);
emit MintedClaimableShares(node, component, sharesReceived);
return sharesReceived;

Function: requestAsyncWithdrawal
âŒ Untouched lines:
address shareToken = IERC7575(component).share();
revert ExceedsAvailableShares(node, component, shares);
uint256 requestId = _requestRedeem(node, component, shares);
revert IncorrectRequestId(requestId);
emit RequestedAsyncWithdrawal(node, component, shares);

Function: executeAsyncWithdrawal
âŒ Untouched lines:
assetsReceived = _executeAsyncWithdrawal(node, component, assets);

Function: _requestDeposit
âŒ Untouched lines:
address underlying = INode(node).asset();
_safeApprove(node, underlying, component, assets);
bytes memory result =
INode(node).execute(component, abi.encodeCall(IERC7540Deposit.requestDeposit, (assets, node, node)));
return abi.decode(result, (uint256));

Function: _mint
âŒ Untouched lines:
bytes memory result =
INode(node).execute(component, abi.encodeCall(IERC7540Deposit.mint, (claimableShares, node, node)));

Function: _requestRedeem
âŒ Untouched lines:
address shareToken = IERC7575(component).share();
_safeApprove(node, shareToken, component, shares);
bytes memory result =
INode(node).execute(component, abi.encodeCall(IERC7540Redeem.requestRedeem, (shares, node, node)));
return abi.decode(result, (uint256));

Function: _withdraw
âŒ Untouched lines:
bytes memory result = INode(node).execute(component, abi.encodeCall(IERC7575.withdraw, (assets, node, node)));
return abi.decode(result, (uint256));

Function: _executeAsyncWithdrawal
âŒ Untouched lines:
revert ExceedsAvailableAssets(node, component, assets);
address asset = IERC7575(node).asset();
uint256 balanceBefore = IERC20(asset).balanceOf(address(node));
_withdraw(node, component, assets);
uint256 balanceAfter = IERC20(asset).balanceOf(address(node));
revert InsufficientAssetsReturned(component, 0, assets);
assetsReceived = balanceAfter - balanceBefore;
revert InsufficientAssetsReturned(component, assetsReceived, assets);
emit AsyncWithdrawalExecuted(node, component, assetsReceived);
return assetsReceived;

âŒ Warning: Coverage 16.42% below threshold 70%
```

</details>

### ERC4626Router

**Coverage:** 14.29%
`â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘`

## ğŸ“ˆ Coverage Statistics

| Metric | Value |
|--------|-------|
| Total Functions | 6 |
| Line Coverage | 14.29% |

## âš ï¸ Uncovered Functions

| Index | Function Name | Touched | Reverted | Untouched Lines |
|-------|---------------|---------|----------|----------------|
| 0 | `claim` | false | false | 4 |

## ğŸ” Uncovered Code Lines

### Function: `claim`

```solidity
âŒ Untouched lines:
```

```solidity
INode(node).execute(
```

```solidity
distributor,
```

```solidity
abi.encodeCall(IFluidDistributor.claim, (node, cumulativeAmount, 1, positionId, cycle, merkleProof, ""))
```

```solidity
emit FluidRewardsClaimed(node, cycle, cumulativeAmount);
```

```solidity
âŒ Warning: Coverage 20% below threshold 70%
```


<details>
<summary>ğŸ“Š Full Coverage Report</summary>

```
ğŸ“„ File: routers/FluidRewardsRouter.sol
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ (index)                    â”‚ Values â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ totalFunctions             â”‚ 1      â”‚
â”‚ fullyCoveredFunctions      â”‚ 0      â”‚
â”‚ coveredLines               â”‚ 1      â”‚
â”‚ revertedLines              â”‚ 0      â”‚
â”‚ untouchedLines             â”‚ 4      â”‚
â”‚ functionCoveragePercentage â”‚ 0      â”‚
â”‚ lineCoveragePercentage     â”‚ 20     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”˜

âš ï¸ Not fully covered functions:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ (index) â”‚ functionName â”‚ touched â”‚ reverted â”‚ untouchedLines â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 0       â”‚ 'claim'      â”‚ false   â”‚ false    â”‚ 4              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Function: claim
âŒ Untouched lines:
INode(node).execute(
distributor,
abi.encodeCall(IFluidDistributor.claim, (node, cumulativeAmount, 1, positionId, cycle, merkleProof, ""))
emit FluidRewardsClaimed(node, cycle, cumulativeAmount);

âŒ Warning: Coverage 20% below threshold 70%
```

</details>

### ERC7540Router

**Coverage:** 16.42%
`â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘`

## ğŸ“ˆ Coverage Statistics

| Metric | Value |
|--------|-------|
| Total Functions | 10 |
| Line Coverage | 16.42% |

## âš ï¸ Uncovered Functions

| Index | Function Name | Touched | Reverted | Untouched Lines |
|-------|---------------|---------|----------|----------------|
| 0 | `claim` | false | false | 3 |

## ğŸ” Uncovered Code Lines

### Function: `claim`

```solidity
âŒ Untouched lines:
```

```solidity
INode(node).execute(
```

```solidity
distributor, abi.encodeCall(IIncentraDistributor.claimAll, (node, campaignAddrs, campaignRewards))
```

```solidity
emit IncentraRewardsClaimed(node);
```

```solidity
âŒ Warning: Coverage 25% below threshold 70%
```


<details>
<summary>ğŸ“Š Full Coverage Report</summary>

```
ğŸ“„ File: routers/IncentraRouter.sol
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ (index)                    â”‚ Values â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ totalFunctions             â”‚ 1      â”‚
â”‚ fullyCoveredFunctions      â”‚ 0      â”‚
â”‚ coveredLines               â”‚ 1      â”‚
â”‚ revertedLines              â”‚ 0      â”‚
â”‚ untouchedLines             â”‚ 3      â”‚
â”‚ functionCoveragePercentage â”‚ 0      â”‚
â”‚ lineCoveragePercentage     â”‚ 25     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”˜

âš ï¸ Not fully covered functions:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ (index) â”‚ functionName â”‚ touched â”‚ reverted â”‚ untouchedLines â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 0       â”‚ 'claim'      â”‚ false   â”‚ false    â”‚ 3              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Function: claim
âŒ Untouched lines:
INode(node).execute(
distributor, abi.encodeCall(IIncentraDistributor.claimAll, (node, campaignAddrs, campaignRewards))
emit IncentraRewardsClaimed(node);

âŒ Warning: Coverage 25% below threshold 70%
```

</details>

### FluidRewardsRouter

**Coverage:** 20%
`â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘`

## ğŸ“ˆ Coverage Statistics

| Metric | Value |
|--------|-------|
| Total Functions | 1 |
| Line Coverage | 20% |

## âš ï¸ Uncovered Functions

| Index | Function Name | Touched | Reverted | Untouched Lines |
|-------|---------------|---------|----------|----------------|
| 0 | `claim` | false | false | 4 |

## ğŸ” Uncovered Code Lines

### Function: `claim`

```solidity
âŒ Untouched lines:
```

```solidity
address[] memory users = new address[](tokens.length);
```

```solidity
users[i] = node;
```

```solidity
INode(node).execute(distributor, abi.encodeCall(IMerklDistributor.claim, (users, tokens, amounts, proofs)));
```

```solidity
emit MerklRewardsClaimed(node, tokens, amounts);
```

```solidity
âŒ Warning: Coverage 20% below threshold 70%
```


<details>
<summary>ğŸ“Š Full Coverage Report</summary>

```
ğŸ“„ File: routers/MerklRouter.sol
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ (index)                    â”‚ Values â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ totalFunctions             â”‚ 1      â”‚
â”‚ fullyCoveredFunctions      â”‚ 0      â”‚
â”‚ coveredLines               â”‚ 1      â”‚
â”‚ revertedLines              â”‚ 0      â”‚
â”‚ untouchedLines             â”‚ 4      â”‚
â”‚ functionCoveragePercentage â”‚ 0      â”‚
â”‚ lineCoveragePercentage     â”‚ 20     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”˜

âš ï¸ Not fully covered functions:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ (index) â”‚ functionName â”‚ touched â”‚ reverted â”‚ untouchedLines â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 0       â”‚ 'claim'      â”‚ false   â”‚ false    â”‚ 4              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Function: claim
âŒ Untouched lines:
address[] memory users = new address[](tokens.length);
users[i] = node;
INode(node).execute(distributor, abi.encodeCall(IMerklDistributor.claim, (users, tokens, amounts, proofs)));
emit MerklRewardsClaimed(node, tokens, amounts);

âŒ Warning: Coverage 20% below threshold 70%
```

</details>

### IncentraRouter

**Coverage:** 25%
`â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘`

## ğŸ“ˆ Coverage Statistics

| Metric | Value |
|--------|-------|
| Total Functions | 1 |
| Line Coverage | 25% |

## âš ï¸ Uncovered Functions

| Index | Function Name | Touched | Reverted | Untouched Lines |
|-------|---------------|---------|----------|----------------|
| 0 | `setIncentiveWhitelistStatus` | false | false | 3 |
| 1 | `setExecutorWhitelistStatus` | false | false | 3 |
| 2 | `swap` | true | false | 19 |

## ğŸ” Uncovered Code Lines

### Function: `setIncentiveWhitelistStatus`

```solidity
âŒ Untouched lines:
```

```solidity
if (incentive == address(0)) revert ErrorsLib.ZeroAddress();
```

```solidity
isIncentiveWhitelisted[incentive] = status;
```

```solidity
emit IncentiveWhitelisted(incentive, status);
```

### Function: `setExecutorWhitelistStatus`

```solidity
âŒ Untouched lines:
```

```solidity
if (executor == address(0)) revert ErrorsLib.ZeroAddress();
```

```solidity
isExecutorWhitelisted[executor] = status;
```

```solidity
emit ExecutorWhitelisted(executor, status);
```

### Function: `swap`

```solidity
âŒ Untouched lines:
```

```solidity
address asset = INode(node).asset();
```

```solidity
require(asset != incentive, IncentiveIsAsset());
```

```solidity
require(!INode(node).isComponent(incentive), IncentiveIsComponent());
```

```solidity
require(isIncentiveWhitelisted[incentive], IncentiveNotWhitelisted());
```

```solidity
require(isExecutorWhitelisted[executor], ExecutorNotWhitelisted());
```

```solidity
require(IERC20(incentive).balanceOf(node) >= incentiveAmount, IncentiveInsufficientAmount());
```

```solidity
_safeApprove(node, incentive, ONE_INCH_AGGREGATION_ROUTER_V6, incentiveAmount);
```

```solidity
IAggregationRouterV6.SwapDescription memory swapDescription = IAggregationRouterV6.SwapDescription({
```

```solidity
srcToken: incentive,
```

```solidity
srcReceiver: executor,
```

```solidity
dstReceiver: node,
```

```solidity
minReturnAmount: minAssetsOut,
```

```solidity
flags: 0
```

```solidity
bytes memory result = INode(node).execute(
```

```solidity
ONE_INCH_AGGREGATION_ROUTER_V6,
```

```solidity
(uint256 returnAmount, uint256 spentAmount) = abi.decode(result, (uint256, uint256));
```

```solidity
require(spentAmount == incentiveAmount, IncentiveIncompleteSwap());
```

```solidity
uint256 returnAmountAfterFee = _subtractExecutionFee(returnAmount, node);
```

```solidity
emit Compounded(node, incentive, incentiveAmount, returnAmount, returnAmountAfterFee);
```

```solidity
âŒ Warning: Coverage 19.35% below threshold 70%
```


<details>
<summary>ğŸ“Š Full Coverage Report</summary>

```
ğŸ“„ File: routers/OneInchV6RouterV1.sol
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ (index)                    â”‚ Values â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ totalFunctions             â”‚ 3      â”‚
â”‚ fullyCoveredFunctions      â”‚ 0      â”‚
â”‚ coveredLines               â”‚ 6      â”‚
â”‚ revertedLines              â”‚ 0      â”‚
â”‚ untouchedLines             â”‚ 25     â”‚
â”‚ functionCoveragePercentage â”‚ 0      â”‚
â”‚ lineCoveragePercentage     â”‚ 19.35  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”˜

âš ï¸ Not fully covered functions:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ (index) â”‚ functionName                  â”‚ touched â”‚ reverted â”‚ untouchedLines â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 0       â”‚ 'setIncentiveWhitelistStatus' â”‚ false   â”‚ false    â”‚ 3              â”‚
â”‚ 1       â”‚ 'setExecutorWhitelistStatus'  â”‚ false   â”‚ false    â”‚ 3              â”‚
â”‚ 2       â”‚ 'swap'                        â”‚ true    â”‚ false    â”‚ 19             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Function: setIncentiveWhitelistStatus
âŒ Untouched lines:
if (incentive == address(0)) revert ErrorsLib.ZeroAddress();
isIncentiveWhitelisted[incentive] = status;
emit IncentiveWhitelisted(incentive, status);

Function: setExecutorWhitelistStatus
âŒ Untouched lines:
if (executor == address(0)) revert ErrorsLib.ZeroAddress();
isExecutorWhitelisted[executor] = status;
emit ExecutorWhitelisted(executor, status);

Function: swap
âŒ Untouched lines:
address asset = INode(node).asset();
require(asset != incentive, IncentiveIsAsset());
require(!INode(node).isComponent(incentive), IncentiveIsComponent());
require(isIncentiveWhitelisted[incentive], IncentiveNotWhitelisted());
require(isExecutorWhitelisted[executor], ExecutorNotWhitelisted());
require(IERC20(incentive).balanceOf(node) >= incentiveAmount, IncentiveInsufficientAmount());
_safeApprove(node, incentive, ONE_INCH_AGGREGATION_ROUTER_V6, incentiveAmount);
IAggregationRouterV6.SwapDescription memory swapDescription = IAggregationRouterV6.SwapDescription({
srcToken: incentive,
srcReceiver: executor,
dstReceiver: node,
minReturnAmount: minAssetsOut,
flags: 0
bytes memory result = INode(node).execute(
ONE_INCH_AGGREGATION_ROUTER_V6,
(uint256 returnAmount, uint256 spentAmount) = abi.decode(result, (uint256, uint256));
require(spentAmount == incentiveAmount, IncentiveIncompleteSwap());
uint256 returnAmountAfterFee = _subtractExecutionFee(returnAmount, node);
emit Compounded(node, incentive, incentiveAmount, returnAmount, returnAmountAfterFee);

âŒ Warning: Coverage 19.35% below threshold 70%
```

</details>

### MerklRouter

**Coverage:** 20%
`â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘`

## ğŸ“ˆ Coverage Statistics

| Metric | Value |
|--------|-------|
| Total Functions | 1 |
| Line Coverage | 20% |

<details>
<summary>ğŸ“Š Full Coverage Report</summary>

```
ğŸ“„ File: quoters/QuoterV1.sol
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ (index)                    â”‚ Values â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ totalFunctions             â”‚ 0      â”‚
â”‚ fullyCoveredFunctions      â”‚ 0      â”‚
â”‚ coveredLines               â”‚ 0      â”‚
â”‚ revertedLines              â”‚ 0      â”‚
â”‚ untouchedLines             â”‚ 0      â”‚
â”‚ functionCoveragePercentage â”‚ 0      â”‚
â”‚ lineCoveragePercentage     â”‚ 0      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”˜

âŒ Warning: Coverage 0% below threshold 70%
```

</details>

### OneInchV6RouterV1

**Coverage:** 19.35%
`â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘`

## ğŸ“ˆ Coverage Statistics

| Metric | Value |
|--------|-------|
| Total Functions | 3 |
| Line Coverage | 19.35% |

## âš ï¸ Uncovered Functions

| Index | Function Name | Touched | Reverted | Untouched Lines |
|-------|---------------|---------|----------|----------------|
| 0 | `setBlacklistStatus` | true | false | 2 |
| 1 | `batchSetWhitelistStatus` | false | false | 7 |
| 2 | `setTolerance` | false | false | 2 |
| 3 | `_computeDepositAmount` | false | false | 6 |
| 4 | `_subtractExecutionFee` | false | false | 5 |
| 5 | `_safeApprove` | false | false | 2 |

## ğŸ” Uncovered Code Lines

### Function: `setBlacklistStatus`

```solidity
âŒ Untouched lines:
```

```solidity
if (component == address(0)) revert ErrorsLib.ZeroAddress();
```

```solidity
isBlacklisted[component] = status;
```

### Function: `batchSetWhitelistStatus`

```solidity
âŒ Untouched lines:
```

```solidity
if (components.length != statuses.length) revert ErrorsLib.LengthMismatch();
```

```solidity
uint256 length = components.length;
```

```solidity
if (components[i] == address(0)) revert ErrorsLib.ZeroAddress();
```

```solidity
isWhitelisted[components[i]] = statuses[i];
```

```solidity
emit EventsLib.ComponentWhitelisted(components[i], statuses[i]);
```

```solidity
unchecked {
```

```solidity
++i;
```

### Function: `setTolerance`

```solidity
âŒ Untouched lines:
```

```solidity
tolerance = newTolerance;
```

```solidity
emit EventsLib.ToleranceUpdated(newTolerance);
```

### Function: `_computeDepositAmount`

```solidity
âŒ Untouched lines:
```

```solidity
(uint256 totalAssets, uint256 currentCash, uint256 idealCashReserve) = _getNodeCashStatus(node);
```

```solidity
_validateReserveAboveTargetRatio(currentCash, idealCashReserve);
```

```solidity
depositAmount = _getInvestmentSize(node, component);
```

```solidity
revert ErrorsLib.ComponentWithinTargetRange(node, component);
```

```solidity
depositAmount = Math.min(depositAmount, currentCash - idealCashReserve);
```

```solidity
depositAmount = _subtractExecutionFee(depositAmount, node);
```

### Function: `_subtractExecutionFee`

```solidity
âŒ Untouched lines:
```

```solidity
uint256 executionFee = transactionAmount * registry.protocolExecutionFee() / WAD;
```

```solidity
return transactionAmount;
```

```solidity
uint256 transactionAfterFee = transactionAmount - executionFee;
```

```solidity
INode(node).subtractProtocolExecutionFee(executionFee);
```

```solidity
return transactionAfterFee;
```

### Function: `_safeApprove`

```solidity
âŒ Untouched lines:
```

```solidity
bytes memory data = INode(node).execute(token, abi.encodeCall(IERC20.approve, (spender, amount)));
```

```solidity
if (!(data.length == 0
```

```solidity
âŒ Warning: Coverage 31.43% below threshold 70%
```


<details>
<summary>ğŸ“Š Full Coverage Report</summary>

```
ğŸ“„ File: libraries/BaseComponentRouter.sol
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ (index)                    â”‚ Values â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ totalFunctions             â”‚ 7      â”‚
â”‚ fullyCoveredFunctions      â”‚ 1      â”‚
â”‚ coveredLines               â”‚ 11     â”‚
â”‚ revertedLines              â”‚ 0      â”‚
â”‚ untouchedLines             â”‚ 24     â”‚
â”‚ functionCoveragePercentage â”‚ 14.29  â”‚
â”‚ lineCoveragePercentage     â”‚ 31.43  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”˜

âš ï¸ Not fully covered functions:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ (index) â”‚ functionName              â”‚ touched â”‚ reverted â”‚ untouchedLines â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 0       â”‚ 'setBlacklistStatus'      â”‚ true    â”‚ false    â”‚ 2              â”‚
â”‚ 1       â”‚ 'batchSetWhitelistStatus' â”‚ false   â”‚ false    â”‚ 7              â”‚
â”‚ 2       â”‚ 'setTolerance'            â”‚ false   â”‚ false    â”‚ 2              â”‚
â”‚ 3       â”‚ '_computeDepositAmount'   â”‚ false   â”‚ false    â”‚ 6              â”‚
â”‚ 4       â”‚ '_subtractExecutionFee'   â”‚ false   â”‚ false    â”‚ 5              â”‚
â”‚ 5       â”‚ '_safeApprove'            â”‚ false   â”‚ false    â”‚ 2              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Function: setBlacklistStatus
âŒ Untouched lines:
if (component == address(0)) revert ErrorsLib.ZeroAddress();
isBlacklisted[component] = status;

Function: batchSetWhitelistStatus
âŒ Untouched lines:
if (components.length != statuses.length) revert ErrorsLib.LengthMismatch();
uint256 length = components.length;
if (components[i] == address(0)) revert ErrorsLib.ZeroAddress();
isWhitelisted[components[i]] = statuses[i];
emit EventsLib.ComponentWhitelisted(components[i], statuses[i]);
unchecked {
++i;

Function: setTolerance
âŒ Untouched lines:
tolerance = newTolerance;
emit EventsLib.ToleranceUpdated(newTolerance);

Function: _computeDepositAmount
âŒ Untouched lines:
(uint256 totalAssets, uint256 currentCash, uint256 idealCashReserve) = _getNodeCashStatus(node);
_validateReserveAboveTargetRatio(currentCash, idealCashReserve);
depositAmount = _getInvestmentSize(node, component);
revert ErrorsLib.ComponentWithinTargetRange(node, component);
depositAmount = Math.min(depositAmount, currentCash - idealCashReserve);
depositAmount = _subtractExecutionFee(depositAmount, node);

Function: _subtractExecutionFee
âŒ Untouched lines:
uint256 executionFee = transactionAmount * registry.protocolExecutionFee() / WAD;
return transactionAmount;
uint256 transactionAfterFee = transactionAmount - executionFee;
INode(node).subtractProtocolExecutionFee(executionFee);
return transactionAfterFee;

Function: _safeApprove
âŒ Untouched lines:
bytes memory data = INode(node).execute(token, abi.encodeCall(IERC20.approve, (spender, amount)));
if (!(data.length == 0

âŒ Warning: Coverage 31.43% below threshold 70%
```

</details>

### QuoterV1

**Coverage:** 0%
`â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘`

## ğŸ“ˆ Coverage Statistics

| Metric | Value |
|--------|-------|
| Total Functions | 0 |
| Line Coverage | 0% |

<details>
<summary>ğŸ“Š Full Coverage Report</summary>

```
ğŸ“„ File: libraries/BaseQuoter.sol
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ (index)                    â”‚ Values â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ totalFunctions             â”‚ 0      â”‚
â”‚ fullyCoveredFunctions      â”‚ 0      â”‚
â”‚ coveredLines               â”‚ 0      â”‚
â”‚ revertedLines              â”‚ 0      â”‚
â”‚ untouchedLines             â”‚ 0      â”‚
â”‚ functionCoveragePercentage â”‚ 0      â”‚
â”‚ lineCoveragePercentage     â”‚ 0      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”˜

âŒ Warning: Coverage 0% below threshold 70%
```

</details>

### BaseComponentRouter

**Coverage:** 31.43%
`â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘`

## ğŸ“ˆ Coverage Statistics

| Metric | Value |
|--------|-------|
| Total Functions | 7 |
| Line Coverage | 31.43% |

<details>
<summary>ğŸ“Š Full Coverage Report</summary>

```
ğŸ“„ File: libraries/ErrorsLib.sol
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ (index)                    â”‚ Values â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ totalFunctions             â”‚ 0      â”‚
â”‚ fullyCoveredFunctions      â”‚ 0      â”‚
â”‚ coveredLines               â”‚ 0      â”‚
â”‚ revertedLines              â”‚ 0      â”‚
â”‚ untouchedLines             â”‚ 0      â”‚
â”‚ functionCoveragePercentage â”‚ 0      â”‚
â”‚ lineCoveragePercentage     â”‚ 0      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”˜

âŒ Warning: Coverage 0% below threshold 70%
```

</details>

### BaseQuoter

**Coverage:** 0%
`â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘`

## ğŸ“ˆ Coverage Statistics

| Metric | Value |
|--------|-------|
| Total Functions | 0 |
| Line Coverage | 0% |

<details>
<summary>ğŸ“Š Full Coverage Report</summary>

```
ğŸ“„ File: libraries/EventsLib.sol
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ (index)                    â”‚ Values â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ totalFunctions             â”‚ 0      â”‚
â”‚ fullyCoveredFunctions      â”‚ 0      â”‚
â”‚ coveredLines               â”‚ 0      â”‚
â”‚ revertedLines              â”‚ 0      â”‚
â”‚ untouchedLines             â”‚ 0      â”‚
â”‚ functionCoveragePercentage â”‚ 0      â”‚
â”‚ lineCoveragePercentage     â”‚ 0      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”˜

âŒ Warning: Coverage 0% below threshold 70%
```

</details>

### ErrorsLib

**Coverage:** 0%
`â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘`

## ğŸ“ˆ Coverage Statistics

| Metric | Value |
|--------|-------|
| Total Functions | 0 |
| Line Coverage | 0% |

<details>
<summary>ğŸ“Š Full Coverage Report</summary>

```
ğŸ“„ File: libraries/MathLib.sol
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ (index)                    â”‚ Values â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ totalFunctions             â”‚ 0      â”‚
â”‚ fullyCoveredFunctions      â”‚ 0      â”‚
â”‚ coveredLines               â”‚ 0      â”‚
â”‚ revertedLines              â”‚ 0      â”‚
â”‚ untouchedLines             â”‚ 0      â”‚
â”‚ functionCoveragePercentage â”‚ 0      â”‚
â”‚ lineCoveragePercentage     â”‚ 0      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”˜

âŒ Warning: Coverage 0% below threshold 70%
```

</details>

### EventsLib

**Coverage:** 0%
`â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘`

## ğŸ“ˆ Coverage Statistics

| Metric | Value |
|--------|-------|
| Total Functions | 0 |
| Line Coverage | 0% |

<details>
<summary>ğŸ“Š Full Coverage Report</summary>

```
ğŸ“„ File: libraries/RegistryAccessControl.sol
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ (index)                    â”‚ Values â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ totalFunctions             â”‚ 0      â”‚
â”‚ fullyCoveredFunctions      â”‚ 0      â”‚
â”‚ coveredLines               â”‚ 0      â”‚
â”‚ revertedLines              â”‚ 0      â”‚
â”‚ untouchedLines             â”‚ 0      â”‚
â”‚ functionCoveragePercentage â”‚ 0      â”‚
â”‚ lineCoveragePercentage     â”‚ 0      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”˜

âŒ Warning: Coverage 0% below threshold 70%
```

</details>

### MathLib

**Coverage:** 0%
`â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘`

## ğŸ“ˆ Coverage Statistics

| Metric | Value |
|--------|-------|
| Total Functions | 0 |
| Line Coverage | 0% |

## âš ï¸ Uncovered Functions

| Index | Function Name | Touched | Reverted | Untouched Lines |
|-------|---------------|---------|----------|----------------|
| 0 | `setPriceDeviation` | false | false | 3 |
| 1 | `setSettlementDeviation` | false | false | 3 |
| 2 | `setPriceUpdateDeviation` | false | false | 2 |
| 3 | `setMinDepositAmount` | false | false | 2 |
| 4 | `setMinRedeemAmount` | false | false | 2 |
| 5 | `forceUpdateLastPrice` | false | false | 3 |
| 6 | `updateLastPrice` | false | false | 3 |
| 7 | `requestDeposit` | false | false | 5 |
| 8 | `settleDeposit` | true | false | 25 |
| 9 | `mint` | false | false | 11 |
| 10 | `requestRedeem` | false | false | 6 |
| 11 | `settleRedeem` | true | false | 25 |
| 12 | `withdraw` | false | false | 12 |
| 13 | `forwardRequestsToDigift` | false | false | 14 |
| 14 | `deposit` | false | false | 1 |
| 15 | `deposit` | false | false | 1 |
| 16 | `mint` | false | false | 1 |
| 17 | `redeem` | false | false | 1 |
| 18 | `setOperator` | false | false | 1 |

## ğŸ” Uncovered Code Lines

### Function: `setPriceDeviation`

```solidity
âŒ Untouched lines:
```

```solidity
require(value <= WAD, InvalidPercentage());
```

```solidity
emit PriceDeviationChange(priceDeviation, value);
```

```solidity
priceDeviation = value;
```

### Function: `setSettlementDeviation`

```solidity
âŒ Untouched lines:
```

```solidity
require(value <= WAD, InvalidPercentage());
```

```solidity
emit SettlementDeviationChange(settlementDeviation, value);
```

```solidity
settlementDeviation = value;
```

### Function: `setPriceUpdateDeviation`

```solidity
âŒ Untouched lines:
```

```solidity
emit PriceUpdateDeviationChange(priceUpdateDeviation, value);
```

```solidity
priceUpdateDeviation = value;
```

### Function: `setMinDepositAmount`

```solidity
âŒ Untouched lines:
```

```solidity
emit MinDepositAmountChange(minDepositAmount, value);
```

```solidity
minDepositAmount = value;
```

### Function: `setMinRedeemAmount`

```solidity
âŒ Untouched lines:
```

```solidity
emit MinRedeemAmountChange(minRedeemAmount, value);
```

```solidity
minRedeemAmount = value;
```

### Function: `forceUpdateLastPrice`

```solidity
âŒ Untouched lines:
```

```solidity
uint256 price = dFeedPriceOracle.getPrice();
```

```solidity
lastPrice = price;
```

```solidity
emit LastPriceUpdate(price);
```

### Function: `updateLastPrice`

```solidity
âŒ Untouched lines:
```

```solidity
uint256 price = _getPrice();
```

```solidity
lastPrice = price;
```

```solidity
emit LastPriceUpdate(price);
```

### Function: `requestDeposit`

```solidity
âŒ Untouched lines:
```

```solidity
_nodeState[msg.sender].pendingDepositRequest = assets;
```

```solidity
_globalState.accumulatedDeposit += assets;
```

```solidity
IERC20(asset).safeTransferFrom(msg.sender, address(this), assets);
```

```solidity
emit DepositRequest(controller, owner, REQUEST_ID, msg.sender, assets);
```

```solidity
return REQUEST_ID;
```

### Function: `settleDeposit`

```solidity
âŒ Untouched lines:
```

```solidity
(uint256 shares, uint256 assets) = digiftEventVerifier.verifySettlementEvent(
```

```solidity
verifyArgs,
```

```solidity
DigiftEventVerifier.EventType.SUBSCRIBE, address(subRedManagement), stToken, asset
```

```solidity
SettleDepositVars memory vars;
```

```solidity
vars.globalPendingDepositRequest = _globalState.pendingDepositRequest;
```

```solidity
vars.settlementValue = convertToAssets(shares) + assets;
```

```solidity
require(vars.globalPendingDepositRequest > 0, NothingToSettle());
```

```solidity
require(
```

```solidity
MathLib.withinRange(vars.globalPendingDepositRequest, vars.settlementValue, settlementDeviation),
```

```solidity
NodeState storage node = _nodeState[nodes[i]];
```

```solidity
uint256 nodePendingDepositRequest = node.pendingDepositRequest;
```

```solidity
require(nodePendingDepositRequest > 0, NoPendingDepositRequest(nodes[i]));
```

```solidity
uint256 assetsToReimburse = nodePendingDepositRequest.mulDiv(assets, vars.globalPendingDepositRequest);
```

```solidity
uint256 sharesToMint = nodePendingDepositRequest.mulDiv(shares, vars.globalPendingDepositRequest);
```

```solidity
vars.totalPendingDepositRequestCheck += nodePendingDepositRequest;
```

```solidity
vars.totalSharesToMint += sharesToMint;
```

```solidity
vars.totalAssetsToReimburse += assetsToReimburse;
```

```solidity
if (vars.totalSharesToMint < shares
```

```solidity
sharesToMint += shares - vars.totalSharesToMint;
```

```solidity
assetsToReimburse += assets - vars.totalAssetsToReimburse;
```

```solidity
node.claimableDepositRequest = nodePendingDepositRequest;
```

```solidity
node.pendingDepositRequest = 0;
```

```solidity
node.maxMint = sharesToMint;
```

```solidity
node.pendingDepositReimbursement = assetsToReimburse;
```

```solidity
emit DepositSettled(nodes[i], sharesToMint, assetsToReimburse);
```

### Function: `mint`

```solidity
âŒ Untouched lines:
```

```solidity
NodeState storage node = _nodeState[msg.sender];
```

```solidity
require(node.claimableDepositRequest > 0, DepositRequestNotFulfilled());
```

```solidity
require(node.maxMint == shares, MintAllSharesOnly());
```

```solidity
assets = node.claimableDepositRequest;
```

```solidity
uint256 assetsToReimburse = node.pendingDepositReimbursement;
```

```solidity
node.claimableDepositRequest = 0;
```

```solidity
node.maxMint = 0;
```

```solidity
node.pendingDepositReimbursement = 0;
```

```solidity
_mint(msg.sender, shares);
```

```solidity
IERC20(asset).safeTransfer(msg.sender, assetsToReimburse);
```

```solidity
emit Deposit(controller, receiver, assets - assetsToReimburse, shares);
```

### Function: `requestRedeem`

```solidity
âŒ Untouched lines:
```

```solidity
_nodeState[msg.sender].pendingRedeemRequest = shares;
```

```solidity
_globalState.accumulatedRedemption += shares;
```

```solidity
_spendAllowance(msg.sender, address(this), shares);
```

```solidity
_transfer(msg.sender, address(this), shares);
```

```solidity
emit RedeemRequest(controller, owner, REQUEST_ID, msg.sender, shares);
```

```solidity
return REQUEST_ID;
```

### Function: `settleRedeem`

```solidity
âŒ Untouched lines:
```

```solidity
(uint256 shares, uint256 assets) = digiftEventVerifier.verifySettlementEvent(
```

```solidity
verifyArgs,
```

```solidity
DigiftEventVerifier.EventType.REDEEM, address(subRedManagement), stToken, asset
```

```solidity
SettleRedeemVars memory vars;
```

```solidity
vars.globalPendingRedeemRequest = _globalState.pendingRedeemRequest;
```

```solidity
vars.settlementValue = convertToShares(assets) + shares;
```

```solidity
require(vars.globalPendingRedeemRequest > 0, NothingToSettle());
```

```solidity
require(
```

```solidity
MathLib.withinRange(vars.globalPendingRedeemRequest, vars.settlementValue, settlementDeviation),
```

```solidity
NodeState storage node = _nodeState[nodes[i]];
```

```solidity
uint256 nodePendingRedeemRequest = node.pendingRedeemRequest;
```

```solidity
require(nodePendingRedeemRequest > 0, NoPendingRedeemRequest(nodes[i]));
```

```solidity
uint256 assetsToReturn = nodePendingRedeemRequest.mulDiv(assets, vars.globalPendingRedeemRequest);
```

```solidity
uint256 sharesToReimburse = nodePendingRedeemRequest.mulDiv(shares, vars.globalPendingRedeemRequest);
```

```solidity
vars.totalPendingRedeemRequestCheck += nodePendingRedeemRequest;
```

```solidity
vars.totalAssetsToReturn += assetsToReturn;
```

```solidity
vars.totalSharesToReimburse += sharesToReimburse;
```

```solidity
if (vars.totalAssetsToReturn < assets
```

```solidity
assetsToReturn += assets - vars.totalAssetsToReturn;
```

```solidity
sharesToReimburse += shares - vars.totalSharesToReimburse;
```

```solidity
node.claimableRedeemRequest = nodePendingRedeemRequest;
```

```solidity
node.pendingRedeemRequest = 0;
```

```solidity
node.maxWithdraw = assetsToReturn;
```

```solidity
node.pendingRedeemReimbursement = sharesToReimburse;
```

```solidity
emit RedeemSettled(nodes[i], sharesToReimburse, assetsToReturn);
```

### Function: `withdraw`

```solidity
âŒ Untouched lines:
```

```solidity
require(_nodeState[msg.sender].claimableRedeemRequest > 0, RedeemRequestNotFulfilled());
```

```solidity
require(_nodeState[msg.sender].maxWithdraw == assets, WithdrawAllAssetsOnly());
```

```solidity
shares = _nodeState[msg.sender].claimableRedeemRequest;
```

```solidity
uint256 sharesToReimburse = _nodeState[msg.sender].pendingRedeemReimbursement;
```

```solidity
uint256 sharesToBurn = shares - sharesToReimburse;
```

```solidity
_nodeState[msg.sender].claimableRedeemRequest = 0;
```

```solidity
_nodeState[msg.sender].maxWithdraw = 0;
```

```solidity
_nodeState[msg.sender].pendingRedeemReimbursement = 0;
```

```solidity
_burn(address(this), sharesToBurn);
```

```solidity
_transfer(address(this), msg.sender, sharesToReimburse);
```

```solidity
IERC20(asset).safeTransfer(msg.sender, assets);
```

```solidity
emit Withdraw(msg.sender, receiver, controller, assets, shares - sharesToReimburse);
```

### Function: `forwardRequestsToDigift`

```solidity
âŒ Untouched lines:
```

```solidity
require(_globalState.pendingDepositRequest == 0, DepositRequestPending());
```

```solidity
require(_globalState.pendingRedeemRequest == 0, RedeemRequestPending());
```

```solidity
uint256 pendingAssets = _globalState.accumulatedDeposit;
```

```solidity
_globalState.accumulatedDeposit = 0;
```

```solidity
_globalState.pendingDepositRequest = pendingAssets;
```

```solidity
IERC20(asset).safeIncreaseAllowance(address(subRedManagement), pendingAssets);
```

```solidity
subRedManagement.subscribe(stToken, asset, pendingAssets, block.timestamp + 1);
```

```solidity
emit DigiftSubscribed(pendingAssets);
```

```solidity
uint256 pendingShares = _globalState.accumulatedRedemption;
```

```solidity
_globalState.accumulatedRedemption = 0;
```

```solidity
_globalState.pendingRedeemRequest = pendingShares;
```

```solidity
IERC20(stToken).safeIncreaseAllowance(address(subRedManagement), pendingShares);
```

```solidity
subRedManagement.redeem(stToken, asset, pendingShares, block.timestamp + 1);
```

```solidity
emit DigiftRedeemed(pendingShares);
```

### Function: `deposit`

```solidity
âŒ Untouched lines:
```

```solidity
revert Unsupported();
```

### Function: `deposit`

```solidity
âŒ Untouched lines:
```

```solidity
revert Unsupported();
```

### Function: `mint`

```solidity
âŒ Untouched lines:
```

```solidity
revert Unsupported();
```

### Function: `redeem`

```solidity
âŒ Untouched lines:
```

```solidity
revert Unsupported();
```

### Function: `setOperator`

```solidity
âŒ Untouched lines:
```

```solidity
revert Unsupported();
```

```solidity
âŒ Warning: Coverage 27.98% below threshold 70%
```


<details>
<summary>ğŸ“Š Full Coverage Report</summary>

```
ğŸ“„ File: digift/DigiftAdapter.sol
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ (index)                    â”‚ Values â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ totalFunctions             â”‚ 22     â”‚
â”‚ fullyCoveredFunctions      â”‚ 3      â”‚
â”‚ coveredLines               â”‚ 47     â”‚
â”‚ revertedLines              â”‚ 0      â”‚
â”‚ untouchedLines             â”‚ 121    â”‚
â”‚ functionCoveragePercentage â”‚ 13.64  â”‚
â”‚ lineCoveragePercentage     â”‚ 27.98  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”˜

âš ï¸ Not fully covered functions:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ (index) â”‚ functionName              â”‚ touched â”‚ reverted â”‚ untouchedLines â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 0       â”‚ 'setPriceDeviation'       â”‚ false   â”‚ false    â”‚ 3              â”‚
â”‚ 1       â”‚ 'setSettlementDeviation'  â”‚ false   â”‚ false    â”‚ 3              â”‚
â”‚ 2       â”‚ 'setPriceUpdateDeviation' â”‚ false   â”‚ false    â”‚ 2              â”‚
â”‚ 3       â”‚ 'setMinDepositAmount'     â”‚ false   â”‚ false    â”‚ 2              â”‚
â”‚ 4       â”‚ 'setMinRedeemAmount'      â”‚ false   â”‚ false    â”‚ 2              â”‚
â”‚ 5       â”‚ 'forceUpdateLastPrice'    â”‚ false   â”‚ false    â”‚ 3              â”‚
â”‚ 6       â”‚ 'updateLastPrice'         â”‚ false   â”‚ false    â”‚ 3              â”‚
â”‚ 7       â”‚ 'requestDeposit'          â”‚ false   â”‚ false    â”‚ 5              â”‚
â”‚ 8       â”‚ 'settleDeposit'           â”‚ true    â”‚ false    â”‚ 25             â”‚
â”‚ 9       â”‚ 'mint'                    â”‚ false   â”‚ false    â”‚ 11             â”‚
â”‚ 10      â”‚ 'requestRedeem'           â”‚ false   â”‚ false    â”‚ 6              â”‚
â”‚ 11      â”‚ 'settleRedeem'            â”‚ true    â”‚ false    â”‚ 25             â”‚
â”‚ 12      â”‚ 'withdraw'                â”‚ false   â”‚ false    â”‚ 12             â”‚
â”‚ 13      â”‚ 'forwardRequestsToDigift' â”‚ false   â”‚ false    â”‚ 14             â”‚
â”‚ 14      â”‚ 'deposit'                 â”‚ false   â”‚ false    â”‚ 1              â”‚
â”‚ 15      â”‚ 'deposit'                 â”‚ false   â”‚ false    â”‚ 1              â”‚
â”‚ 16      â”‚ 'mint'                    â”‚ false   â”‚ false    â”‚ 1              â”‚
â”‚ 17      â”‚ 'redeem'                  â”‚ false   â”‚ false    â”‚ 1              â”‚
â”‚ 18      â”‚ 'setOperator'             â”‚ false   â”‚ false    â”‚ 1              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Function: setPriceDeviation
âŒ Untouched lines:
require(value <= WAD, InvalidPercentage());
emit PriceDeviationChange(priceDeviation, value);
priceDeviation = value;

Function: setSettlementDeviation
âŒ Untouched lines:
require(value <= WAD, InvalidPercentage());
emit SettlementDeviationChange(settlementDeviation, value);
settlementDeviation = value;

Function: setPriceUpdateDeviation
âŒ Untouched lines:
emit PriceUpdateDeviationChange(priceUpdateDeviation, value);
priceUpdateDeviation = value;

Function: setMinDepositAmount
âŒ Untouched lines:
emit MinDepositAmountChange(minDepositAmount, value);
minDepositAmount = value;

Function: setMinRedeemAmount
âŒ Untouched lines:
emit MinRedeemAmountChange(minRedeemAmount, value);
minRedeemAmount = value;

Function: forceUpdateLastPrice
âŒ Untouched lines:
uint256 price = dFeedPriceOracle.getPrice();
lastPrice = price;
emit LastPriceUpdate(price);

Function: updateLastPrice
âŒ Untouched lines:
uint256 price = _getPrice();
lastPrice = price;
emit LastPriceUpdate(price);

Function: requestDeposit
âŒ Untouched lines:
_nodeState[msg.sender].pendingDepositRequest = assets;
_globalState.accumulatedDeposit += assets;
IERC20(asset).safeTransferFrom(msg.sender, address(this), assets);
emit DepositRequest(controller, owner, REQUEST_ID, msg.sender, assets);
return REQUEST_ID;

Function: settleDeposit
âŒ Untouched lines:
(uint256 shares, uint256 assets) = digiftEventVerifier.verifySettlementEvent(
verifyArgs,
DigiftEventVerifier.EventType.SUBSCRIBE, address(subRedManagement), stToken, asset
SettleDepositVars memory vars;
vars.globalPendingDepositRequest = _globalState.pendingDepositRequest;
vars.settlementValue = convertToAssets(shares) + assets;
require(vars.globalPendingDepositRequest > 0, NothingToSettle());
require(
MathLib.withinRange(vars.globalPendingDepositRequest, vars.settlementValue, settlementDeviation),
NodeState storage node = _nodeState[nodes[i]];
uint256 nodePendingDepositRequest = node.pendingDepositRequest;
require(nodePendingDepositRequest > 0, NoPendingDepositRequest(nodes[i]));
uint256 assetsToReimburse = nodePendingDepositRequest.mulDiv(assets, vars.globalPendingDepositRequest);
uint256 sharesToMint = nodePendingDepositRequest.mulDiv(shares, vars.globalPendingDepositRequest);
vars.totalPendingDepositRequestCheck += nodePendingDepositRequest;
vars.totalSharesToMint += sharesToMint;
vars.totalAssetsToReimburse += assetsToReimburse;
if (vars.totalSharesToMint < shares
sharesToMint += shares - vars.totalSharesToMint;
assetsToReimburse += assets - vars.totalAssetsToReimburse;
node.claimableDepositRequest = nodePendingDepositRequest;
node.pendingDepositRequest = 0;
node.maxMint = sharesToMint;
node.pendingDepositReimbursement = assetsToReimburse;
emit DepositSettled(nodes[i], sharesToMint, assetsToReimburse);

Function: mint
âŒ Untouched lines:
NodeState storage node = _nodeState[msg.sender];
require(node.claimableDepositRequest > 0, DepositRequestNotFulfilled());
require(node.maxMint == shares, MintAllSharesOnly());
assets = node.claimableDepositRequest;
uint256 assetsToReimburse = node.pendingDepositReimbursement;
node.claimableDepositRequest = 0;
node.maxMint = 0;
node.pendingDepositReimbursement = 0;
_mint(msg.sender, shares);
IERC20(asset).safeTransfer(msg.sender, assetsToReimburse);
emit Deposit(controller, receiver, assets - assetsToReimburse, shares);

Function: requestRedeem
âŒ Untouched lines:
_nodeState[msg.sender].pendingRedeemRequest = shares;
_globalState.accumulatedRedemption += shares;
_spendAllowance(msg.sender, address(this), shares);
_transfer(msg.sender, address(this), shares);
emit RedeemRequest(controller, owner, REQUEST_ID, msg.sender, shares);
return REQUEST_ID;

Function: settleRedeem
âŒ Untouched lines:
(uint256 shares, uint256 assets) = digiftEventVerifier.verifySettlementEvent(
verifyArgs,
DigiftEventVerifier.EventType.REDEEM, address(subRedManagement), stToken, asset
SettleRedeemVars memory vars;
vars.globalPendingRedeemRequest = _globalState.pendingRedeemRequest;
vars.settlementValue = convertToShares(assets) + shares;
require(vars.globalPendingRedeemRequest > 0, NothingToSettle());
require(
MathLib.withinRange(vars.globalPendingRedeemRequest, vars.settlementValue, settlementDeviation),
NodeState storage node = _nodeState[nodes[i]];
uint256 nodePendingRedeemRequest = node.pendingRedeemRequest;
require(nodePendingRedeemRequest > 0, NoPendingRedeemRequest(nodes[i]));
uint256 assetsToReturn = nodePendingRedeemRequest.mulDiv(assets, vars.globalPendingRedeemRequest);
uint256 sharesToReimburse = nodePendingRedeemRequest.mulDiv(shares, vars.globalPendingRedeemRequest);
vars.totalPendingRedeemRequestCheck += nodePendingRedeemRequest;
vars.totalAssetsToReturn += assetsToReturn;
vars.totalSharesToReimburse += sharesToReimburse;
if (vars.totalAssetsToReturn < assets
assetsToReturn += assets - vars.totalAssetsToReturn;
sharesToReimburse += shares - vars.totalSharesToReimburse;
node.claimableRedeemRequest = nodePendingRedeemRequest;
node.pendingRedeemRequest = 0;
node.maxWithdraw = assetsToReturn;
node.pendingRedeemReimbursement = sharesToReimburse;
emit RedeemSettled(nodes[i], sharesToReimburse, assetsToReturn);

Function: withdraw
âŒ Untouched lines:
require(_nodeState[msg.sender].claimableRedeemRequest > 0, RedeemRequestNotFulfilled());
require(_nodeState[msg.sender].maxWithdraw == assets, WithdrawAllAssetsOnly());
shares = _nodeState[msg.sender].claimableRedeemRequest;
uint256 sharesToReimburse = _nodeState[msg.sender].pendingRedeemReimbursement;
uint256 sharesToBurn = shares - sharesToReimburse;
_nodeState[msg.sender].claimableRedeemRequest = 0;
_nodeState[msg.sender].maxWithdraw = 0;
_nodeState[msg.sender].pendingRedeemReimbursement = 0;
_burn(address(this), sharesToBurn);
_transfer(address(this), msg.sender, sharesToReimburse);
IERC20(asset).safeTransfer(msg.sender, assets);
emit Withdraw(msg.sender, receiver, controller, assets, shares - sharesToReimburse);

Function: forwardRequestsToDigift
âŒ Untouched lines:
require(_globalState.pendingDepositRequest == 0, DepositRequestPending());
require(_globalState.pendingRedeemRequest == 0, RedeemRequestPending());
uint256 pendingAssets = _globalState.accumulatedDeposit;
_globalState.accumulatedDeposit = 0;
_globalState.pendingDepositRequest = pendingAssets;
IERC20(asset).safeIncreaseAllowance(address(subRedManagement), pendingAssets);
subRedManagement.subscribe(stToken, asset, pendingAssets, block.timestamp + 1);
emit DigiftSubscribed(pendingAssets);
uint256 pendingShares = _globalState.accumulatedRedemption;
_globalState.accumulatedRedemption = 0;
_globalState.pendingRedeemRequest = pendingShares;
IERC20(stToken).safeIncreaseAllowance(address(subRedManagement), pendingShares);
subRedManagement.redeem(stToken, asset, pendingShares, block.timestamp + 1);
emit DigiftRedeemed(pendingShares);

Function: deposit
âŒ Untouched lines:
revert Unsupported();

Function: deposit
âŒ Untouched lines:
revert Unsupported();

Function: mint
âŒ Untouched lines:
revert Unsupported();

Function: redeem
âŒ Untouched lines:
revert Unsupported();

Function: setOperator
âŒ Untouched lines:
revert Unsupported();

âŒ Warning: Coverage 27.98% below threshold 70%
```

</details>

### RegistryAccessControl

**Coverage:** 0%
`â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘`

## ğŸ“ˆ Coverage Statistics

| Metric | Value |
|--------|-------|
| Total Functions | 0 |
| Line Coverage | 0% |

## âš ï¸ Uncovered Functions

| Index | Function Name | Touched | Reverted | Untouched Lines |
|-------|---------------|---------|----------|----------------|
| 0 | `setWhitelist` | false | false | 2 |
| 1 | `setBlockHash` | false | false | 2 |
| 2 | `verifySettlementEvent` | true | false | 27 |
| 3 | `_getBlockHash` | false | false | 4 |

## ğŸ” Uncovered Code Lines

### Function: `setWhitelist`

```solidity
âŒ Untouched lines:
```

```solidity
whitelist[digiftAdapter] = status;
```

```solidity
emit WhitelistChange(digiftAdapter, status);
```

### Function: `setBlockHash`

```solidity
âŒ Untouched lines:
```

```solidity
blockHashes[blockNumber] = blockHash;
```

```solidity
emit BlockHashSet(blockNumber, blockHash);
```

### Function: `verifySettlementEvent`

```solidity
âŒ Untouched lines:
```

```solidity
require(whitelist[msg.sender], NotWhitelisted());
```

```solidity
Vars memory vars;
```

```solidity
vars.blockHash = keccak256(fargs.headerRlp);
```

```solidity
vars.eventSignature = nargs.eventType == EventType.SUBSCRIBE ? SETTLE_SUBSCRIBER_TOPIC : SETTLE_REDEMPTION_TOPIC;
```

```solidity
if (_getBlockHash(fargs.blockNumber) != vars.blockHash) revert BadHeader();
```

```solidity
vars.receiptsRoot = bytes32(RLPReader.readBytes(RLPReader.readList(fargs.headerRlp)[5]));
```

```solidity
vars.logs = RLPReader.readList(
```

```solidity
RLPReader.readList(_stripTypedPrefix(MerkleTrie.get(fargs.txIndex, fargs.proof, vars.receiptsRoot)))[3]
```

```solidity
vars.log = RLPReader.readList(vars.logs[i]);
```

```solidity
if (address(bytes20(RLPReader.readBytes(vars.log[0]))) != nargs.emittingAddress) continue;
```

```solidity
RLPReader.RLPItem[] memory topics = RLPReader.readList(vars.log[1]);
```

```solidity
if (bytes32(RLPReader.readBytes(topics[0])) != vars.eventSignature) continue;
```

```solidity
address stToken,
```

```solidity
RLPReader.readBytes(vars.log[2]), (address, address[], uint256[], address[], uint256[], uint256[])
```

```solidity
if (stToken != nargs.securityToken) continue;
```

```solidity
vars.investorIndex = type(uint256).max;
```

```solidity
vars.investorIndex = j;
```

```solidity
break;
```

```solidity
if (vars.investorIndex == type(uint256).max) continue; // Caller not in investor list
```

```solidity
if (currencyTokenList[vars.investorIndex] != nargs.currencyToken) continue;
```

```solidity
vars.logHash = _hashLog(vars.blockHash, vars.receiptsRoot, fargs.txIndex, i);
```

```solidity
if (usedLogs[vars.logHash]) revert LogAlreadyUsed();
```

```solidity
usedLogs[vars.logHash] = true;
```

```solidity
emit Verified(
```

```solidity
msg.sender,
```

```solidity
return (quantityList[vars.investorIndex], amountList[vars.investorIndex]);
```

```solidity
revert NoEvent();
```

### Function: `_getBlockHash`

```solidity
âŒ Untouched lines:
```

```solidity
bytes32 blockHash = blockhash(blockNumber);
```

```solidity
blockHash = blockHashes[blockNumber];
```

```solidity
if (blockHash == 0) revert MissedWindow();
```

```solidity
return blockHash;
```

```solidity
âŒ Warning: Coverage 30% below threshold 70%
```


<details>
<summary>ğŸ“Š Full Coverage Report</summary>

```
ğŸ“„ File: digift/DigiftEventVerifier.sol
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ (index)                    â”‚ Values â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ totalFunctions             â”‚ 4      â”‚
â”‚ fullyCoveredFunctions      â”‚ 0      â”‚
â”‚ coveredLines               â”‚ 15     â”‚
â”‚ revertedLines              â”‚ 0      â”‚
â”‚ untouchedLines             â”‚ 35     â”‚
â”‚ functionCoveragePercentage â”‚ 0      â”‚
â”‚ lineCoveragePercentage     â”‚ 30     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”˜

âš ï¸ Not fully covered functions:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ (index) â”‚ functionName            â”‚ touched â”‚ reverted â”‚ untouchedLines â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 0       â”‚ 'setWhitelist'          â”‚ false   â”‚ false    â”‚ 2              â”‚
â”‚ 1       â”‚ 'setBlockHash'          â”‚ false   â”‚ false    â”‚ 2              â”‚
â”‚ 2       â”‚ 'verifySettlementEvent' â”‚ true    â”‚ false    â”‚ 27             â”‚
â”‚ 3       â”‚ '_getBlockHash'         â”‚ false   â”‚ false    â”‚ 4              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Function: setWhitelist
âŒ Untouched lines:
whitelist[digiftAdapter] = status;
emit WhitelistChange(digiftAdapter, status);

Function: setBlockHash
âŒ Untouched lines:
blockHashes[blockNumber] = blockHash;
emit BlockHashSet(blockNumber, blockHash);

Function: verifySettlementEvent
âŒ Untouched lines:
require(whitelist[msg.sender], NotWhitelisted());
Vars memory vars;
vars.blockHash = keccak256(fargs.headerRlp);
vars.eventSignature = nargs.eventType == EventType.SUBSCRIBE ? SETTLE_SUBSCRIBER_TOPIC : SETTLE_REDEMPTION_TOPIC;
if (_getBlockHash(fargs.blockNumber) != vars.blockHash) revert BadHeader();
vars.receiptsRoot = bytes32(RLPReader.readBytes(RLPReader.readList(fargs.headerRlp)[5]));
vars.logs = RLPReader.readList(
RLPReader.readList(_stripTypedPrefix(MerkleTrie.get(fargs.txIndex, fargs.proof, vars.receiptsRoot)))[3]
vars.log = RLPReader.readList(vars.logs[i]);
if (address(bytes20(RLPReader.readBytes(vars.log[0]))) != nargs.emittingAddress) continue;
RLPReader.RLPItem[] memory topics = RLPReader.readList(vars.log[1]);
if (bytes32(RLPReader.readBytes(topics[0])) != vars.eventSignature) continue;
address stToken,
RLPReader.readBytes(vars.log[2]), (address, address[], uint256[], address[], uint256[], uint256[])
if (stToken != nargs.securityToken) continue;
vars.investorIndex = type(uint256).max;
vars.investorIndex = j;
break;
if (vars.investorIndex == type(uint256).max) continue; // Caller not in investor list
if (currencyTokenList[vars.investorIndex] != nargs.currencyToken) continue;
vars.logHash = _hashLog(vars.blockHash, vars.receiptsRoot, fargs.txIndex, i);
if (usedLogs[vars.logHash]) revert LogAlreadyUsed();
usedLogs[vars.logHash] = true;
emit Verified(
msg.sender,
return (quantityList[vars.investorIndex], amountList[vars.investorIndex]);
revert NoEvent();

Function: _getBlockHash
âŒ Untouched lines:
bytes32 blockHash = blockhash(blockNumber);
blockHash = blockHashes[blockNumber];
if (blockHash == 0) revert MissedWindow();
return blockHash;

âŒ Warning: Coverage 30% below threshold 70%
```

</details>

### DigiftAdapter

**Coverage:** 27.98%
`â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘`

## ğŸ“ˆ Coverage Statistics

| Metric | Value |
|--------|-------|
| Total Functions | 22 |
| Line Coverage | 27.98% |

### DigiftAdapterFactory

**Coverage:** 100%
`â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ`

## ğŸ“ˆ Coverage Statistics

| Metric | Value |
|--------|-------|
| Total Functions | 1 |
| Line Coverage | 100% |

### DigiftEventVerifier

**Coverage:** 30%
`â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘`

## ğŸ“ˆ Coverage Statistics

| Metric | Value |
|--------|-------|
| Total Functions | 4 |
| Line Coverage | 30% |

## ğŸ’¡ Recommendations

The following contracts need attention to meet the 70% coverage threshold:

- **Escrow**: Needs 70% improvement (current: 0%)
- **Node**: Needs 4.94% improvement (current: 65.06%)
- **ERC4626Router**: Needs 55.71% improvement (current: 14.29%)
- **ERC7540Router**: Needs 53.58% improvement (current: 16.42%)
- **FluidRewardsRouter**: Needs 50% improvement (current: 20%)
- **IncentraRouter**: Needs 45% improvement (current: 25%)
- **MerklRouter**: Needs 50% improvement (current: 20%)
- **OneInchV6RouterV1**: Needs 50.65% improvement (current: 19.35%)
- **QuoterV1**: Needs 70% improvement (current: 0%)
- **BaseComponentRouter**: Needs 38.57% improvement (current: 31.43%)
- **BaseQuoter**: Needs 70% improvement (current: 0%)
- **ErrorsLib**: Needs 70% improvement (current: 0%)
- **EventsLib**: Needs 70% improvement (current: 0%)
- **MathLib**: Needs 70% improvement (current: 0%)
- **RegistryAccessControl**: Needs 70% improvement (current: 0%)
- **DigiftAdapter**: Needs 42.02% improvement (current: 27.98%)
- **DigiftEventVerifier**: Needs 40% improvement (current: 30%)

### Next Steps:
1. Focus on contracts with coverage below 30% first
2. Add test cases for uncovered functions
3. Review and test edge cases
4. Run echidna with longer campaign for better coverage

---
*Report generated by echidna-coverage-analyzer.sh*
